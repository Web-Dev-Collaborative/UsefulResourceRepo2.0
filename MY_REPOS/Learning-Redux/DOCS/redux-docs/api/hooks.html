<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
  <head>
    <meta charset="utf-8" />
    <meta name="generator" content="pandoc" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, user-scalable=yes"
    />
    <title>Hooks</title>
    <style type="text/css">
      code {
        white-space: pre-wrap;
      }
      span.smallcaps {
        font-variant: small-caps;
      }
      span.underline {
        text-decoration: underline;
      }
      div.column {
        display: inline-block;
        vertical-align: top;
        width: 50%;
      }
    </style>
    <style type="text/css">
      a.sourceLine {
        display: inline-block;
        line-height: 1.25;
      }
      a.sourceLine {
        pointer-events: none;
        color: inherit;
        text-decoration: inherit;
      }
      a.sourceLine:empty {
        height: 1.2em;
      }
      .sourceCode {
        overflow: visible;
      }
      code.sourceCode {
        white-space: pre;
        position: relative;
      }
      div.sourceCode {
        margin: 1em 0;
      }
      pre.sourceCode {
        margin: 0;
      }
      @media screen {
        div.sourceCode {
          overflow: auto;
        }
      }
      @media print {
        code.sourceCode {
          white-space: pre-wrap;
        }
        a.sourceLine {
          text-indent: -1em;
          padding-left: 1em;
        }
      }
      pre.numberSource a.sourceLine {
        position: relative;
        left: -4em;
      }
      pre.numberSource a.sourceLine::before {
        content: attr(title);
        position: relative;
        left: -1em;
        text-align: right;
        vertical-align: baseline;
        border: none;
        pointer-events: all;
        display: inline-block;
        -webkit-touch-callout: none;
        -webkit-user-select: none;
        -khtml-user-select: none;
        -moz-user-select: none;
        -ms-user-select: none;
        user-select: none;
        padding: 0 4px;
        width: 4em;
        color: #aaaaaa;
      }
      pre.numberSource {
        margin-left: 3em;
        border-left: 1px solid #aaaaaa;
        padding-left: 4px;
      }
      div.sourceCode {
      }
      @media screen {
        a.sourceLine::before {
          text-decoration: underline;
        }
      }
      code span.al {
        color: #ff0000;
        font-weight: bold;
      } /* Alert */
      code span.an {
        color: #60a0b0;
        font-weight: bold;
        font-style: italic;
      } /* Annotation */
      code span.at {
        color: #7d9029;
      } /* Attribute */
      code span.bn {
        color: #40a070;
      } /* BaseN */
      code span.bu {
      } /* BuiltIn */
      code span.cf {
        color: #007020;
        font-weight: bold;
      } /* ControlFlow */
      code span.ch {
        color: #4070a0;
      } /* Char */
      code span.cn {
        color: #880000;
      } /* Constant */
      code span.co {
        color: #60a0b0;
        font-style: italic;
      } /* Comment */
      code span.cv {
        color: #60a0b0;
        font-weight: bold;
        font-style: italic;
      } /* CommentVar */
      code span.do {
        color: #ba2121;
        font-style: italic;
      } /* Documentation */
      code span.dt {
        color: #902000;
      } /* DataType */
      code span.dv {
        color: #40a070;
      } /* DecVal */
      code span.er {
        color: #ff0000;
        font-weight: bold;
      } /* Error */
      code span.ex {
      } /* Extension */
      code span.fl {
        color: #40a070;
      } /* Float */
      code span.fu {
        color: #06287e;
      } /* Function */
      code span.im {
      } /* Import */
      code span.in {
        color: #60a0b0;
        font-weight: bold;
        font-style: italic;
      } /* Information */
      code span.kw {
        color: #007020;
        font-weight: bold;
      } /* Keyword */
      code span.op {
        color: #666666;
      } /* Operator */
      code span.ot {
        color: #007020;
      } /* Other */
      code span.pp {
        color: #bc7a00;
      } /* Preprocessor */
      code span.sc {
        color: #4070a0;
      } /* SpecialChar */
      code span.ss {
        color: #bb6688;
      } /* SpecialString */
      code span.st {
        color: #4070a0;
      } /* String */
      code span.va {
        color: #19177c;
      } /* Variable */
      code span.vs {
        color: #4070a0;
      } /* VerbatimString */
      code span.wa {
        color: #60a0b0;
        font-weight: bold;
        font-style: italic;
      } /* Warning */
    </style>
  </head>
  <body>
    <header id="title-block-header">
      <h1 class="title">Hooks</h1>
    </header>
    <p> </p>
    <h1 id="hooks">Hooks</h1>
    <p>
      React’s new
      <a href="https://reactjs.org/docs/hooks-intro.html">“hooks” APIs</a> give
      function components the ability to use local component state, execute side
      effects, and more. React also lets us write
      <a href="https://reactjs.org/docs/hooks-custom.html">custom hooks</a>,
      which let us extract reusable hooks to add our own behavior on top of
      React’s built-in hooks.
    </p>
    <p>
      React Redux includes its own custom hook APIs, which allow your React
      components to subscribe to the Redux store and dispatch actions.
    </p>
    <div class="tip">
      <p>
        <strong
          >We recommend using the React-Redux hooks API as the default approach
          in your React components.</strong
        >
      </p>
      <p>
        The existing <code>connect</code> API still works and will continue to
        be supported, but the hooks API is simpler and works better with
        TypeScript.
      </p>
    </div>
    <p>These hooks were first added in v7.1.0.</p>
    <h2 id="using-hooks-in-a-react-redux-app">
      Using Hooks in a React Redux App
    </h2>
    <p>
      As with <code>connect()</code>, you should start by wrapping your entire
      application in a <code>&lt;Provider&gt;</code> component to make the store
      available throughout the component tree:
    </p>
    <pre class="jsx"><code>const store = createStore(rootReducer)

ReactDOM.render(
  &lt;Provider store={store}&gt;
    &lt;App /&gt;
  &lt;/Provider&gt;,
  document.getElementById(&#39;root&#39;)
)</code></pre>
    <p>
      From there, you may import any of the listed React Redux hooks APIs and
      use them within your function components.
    </p>
    <h2 id="useselector"><code>useSelector()</code></h2>
    <div class="sourceCode" id="cb2">
      <pre
        class="sourceCode js"
      ><code class="sourceCode javascript"><a class="sourceLine" id="cb2-1" title="1"><span class="kw">const</span> result<span class="op">:</span> any <span class="op">=</span> <span class="at">useSelector</span>(selector<span class="op">:</span> Function<span class="op">,</span> equalityFn<span class="op">?</span>: Function)</a></code></pre>
    </div>
    <p>
      Allows you to extract data from the Redux store state, using a selector
      function.
    </p>
    <div class="info">
      <p>
        The selector function should be
        <a href="https://en.wikipedia.org/wiki/Pure_function">pure</a> since it
        is potentially executed multiple times and at arbitrary points in time.
      </p>
    </div>
    <p>
      The selector is approximately equivalent to the
      <a href="../using-react-redux/connect-mapstate"
        ><code>mapStateToProps</code> argument to <code>connect</code></a
      >
      conceptually. The selector will be called with the entire Redux store
      state as its only argument. The selector will be run whenever the function
      component renders (unless its reference hasn’t changed since a previous
      render of the component so that a cached result can be returned by the
      hook without re-running the selector). <code>useSelector()</code> will
      also subscribe to the Redux store, and run your selector whenever an
      action is dispatched.
    </p>
    <p>
      However, there are some differences between the selectors passed to
      <code>useSelector()</code> and a <code>mapState</code> function:
    </p>
    <ul>
      <li>
        The selector may return any value as a result, not just an object. The
        return value of the selector will be used as the return value of the
        <code>useSelector()</code> hook.
      </li>
      <li>
        When an action is dispatched, <code>useSelector()</code> will do a
        reference comparison of the previous selector result value and the
        current result value. If they are different, the component will be
        forced to re-render. If they are the same, the component will not
        re-render.
      </li>
      <li>
        The selector function does <em>not</em> receive an
        <code>ownProps</code> argument. However, props can be used through
        closure (see the examples below) or by using a curried selector.
      </li>
      <li>
        Extra care must be taken when using memoizing selectors (see examples
        below for more details).
      </li>
      <li>
        <code>useSelector()</code> uses strict <code>===</code> reference
        equality checks by default, not shallow equality (see the following
        section for more details).
      </li>
    </ul>
    <div class="info">
      <p>
        There are potential edge cases with using props in selectors that may
        cause issues. See the
        <a href="#usage-warnings">Usage Warnings</a> section of this page for
        further details.
      </p>
    </div>
    <p>
      You may call <code>useSelector()</code> multiple times within a single
      function component. Each call to <code>useSelector()</code> creates an
      individual subscription to the Redux store. Because of the React update
      batching behavior used in React Redux v7, a dispatched action that causes
      multiple <code>useSelector()</code>s in the same component to return new
      values <em>should</em> only result in a single re-render.
    </p>
    <h3 id="equality-comparisons-and-updates">
      Equality Comparisons and Updates
    </h3>
    <p>
      When the function component renders, the provided selector function will
      be called and its result will be returned from the
      <code>useSelector()</code> hook. (A cached result may be returned by the
      hook without re-running the selector if it’s the same function reference
      as on a previous render of the component.)
    </p>
    <p>
      However, when an action is dispatched to the Redux store,
      <code>useSelector()</code> only forces a re-render if the selector result
      appears to be different than the last result. As of v7.1.0-alpha.5, the
      default comparison is a strict <code>===</code> reference comparison. This
      is different than <code>connect()</code>, which uses shallow equality
      checks on the results of <code>mapState</code> calls to determine if
      re-rendering is needed. This has several implications on how you should
      use <code>useSelector()</code>.
    </p>
    <p>
      With <code>mapState</code>, all individual fields were returned in a
      combined object. It didn’t matter if the return object was a new reference
      or not - <code>connect()</code> just compared the individual fields. With
      <code>useSelector()</code>, returning a new object every time will
      <em>always</em> force a re-render by default. If you want to retrieve
      multiple values from the store, you can:
    </p>
    <ul>
      <li>
        Call <code>useSelector()</code> multiple times, with each call returning
        a single field value
      </li>
      <li>
        Use Reselect or a similar library to create a memoized selector that
        returns multiple values in one object, but only returns a new object
        when one of the values has changed.
      </li>
      <li>
        Use the <code>shallowEqual</code> function from React-Redux as the
        <code>equalityFn</code> argument to <code>useSelector()</code>, like:
      </li>
    </ul>
    <div class="sourceCode" id="cb3">
      <pre
        class="sourceCode js"
      ><code class="sourceCode javascript"><a class="sourceLine" id="cb3-1" title="1"><span class="im">import</span> <span class="op">{</span> shallowEqual<span class="op">,</span> useSelector <span class="op">}</span> <span class="im">from</span> <span class="st">&#39;react-redux&#39;</span></a>
<a class="sourceLine" id="cb3-2" title="2"></a>
<a class="sourceLine" id="cb3-3" title="3"><span class="co">// later</span></a>
<a class="sourceLine" id="cb3-4" title="4"><span class="kw">const</span> selectedData <span class="op">=</span> <span class="at">useSelector</span>(selectorReturningObject<span class="op">,</span> shallowEqual)</a></code></pre>
    </div>
    <p>
      The optional comparison function also enables using something like
      Lodash’s <code>_.isEqual()</code> or Immutable.js’s comparison
      capabilities.
    </p>
    <h3 id="useselector-examples"><code>useSelector</code> Examples</h3>
    <p>Basic usage:</p>
    <pre class="jsx"><code>import React from &#39;react&#39;
import { useSelector } from &#39;react-redux&#39;

export const CounterComponent = () =&gt; {
  const counter = useSelector((state) =&gt; state.counter)
  return &lt;div&gt;{counter}&lt;/div&gt;
}</code></pre>
    <p>Using props via closure to determine what to extract:</p>
    <pre class="jsx"><code>import React from &#39;react&#39;
import { useSelector } from &#39;react-redux&#39;

export const TodoListItem = (props) =&gt; {
  const todo = useSelector((state) =&gt; state.todos[props.id])
  return &lt;div&gt;{todo.text}&lt;/div&gt;
}</code></pre>
    <h4 id="using-memoizing-selectors">Using memoizing selectors</h4>
    <p>
      When using <code>useSelector</code> with an inline selector as shown
      above, a new instance of the selector is created whenever the component is
      rendered. This works as long as the selector does not maintain any state.
      However, memoizing selectors (e.g. created via
      <code>createSelector</code> from <code>reselect</code>) do have internal
      state, and therefore care must be taken when using them. Below you can
      find typical usage scenarios for memoizing selectors.
    </p>
    <p>
      When the selector does only depend on the state, simply ensure that it is
      declared outside of the component so that the same selector instance is
      used for each render:
    </p>
    <pre class="jsx"><code>import React from &#39;react&#39;
import { useSelector } from &#39;react-redux&#39;
import { createSelector } from &#39;reselect&#39;

const selectNumCompletedTodos = createSelector(
  (state) =&gt; state.todos,
  (todos) =&gt; todos.filter((todo) =&gt; todo.completed).length
)

export const CompletedTodosCounter = () =&gt; {
  const numCompletedTodos = useSelector(selectNumCompletedTodos)
  return &lt;div&gt;{numCompletedTodos}&lt;/div&gt;
}

export const App = () =&gt; {
  return (
    &lt;&gt;
      &lt;span&gt;Number of completed todos:&lt;/span&gt;
      &lt;CompletedTodosCounter /&gt;
    &lt;/&gt;
  )
}</code></pre>
    <p>
      The same is true if the selector depends on the component’s props, but
      will only ever be used in a single instance of a single component:
    </p>
    <pre class="jsx"><code>import React from &#39;react&#39;
import { useSelector } from &#39;react-redux&#39;
import { createSelector } from &#39;reselect&#39;

const selectCompletedTodosCount = createSelector(
  (state) =&gt; state.todos,
  (_, completed) =&gt; completed,
  (todos, completed) =&gt;
    todos.filter((todo) =&gt; todo.completed === completed).length
)

export const CompletedTodosCount = ({ completed }) =&gt; {
  const matchingCount = useSelector((state) =&gt;
    selectCompletedTodosCount(state, completed)
  )

  return &lt;div&gt;{matchingCount}&lt;/div&gt;
}

export const App = () =&gt; {
  return (
    &lt;&gt;
      &lt;span&gt;Number of done todos:&lt;/span&gt;
      &lt;CompletedTodosCount completed={true} /&gt;
    &lt;/&gt;
  )
}</code></pre>
    <p>
      However, when the selector is used in multiple component instances and
      depends on the component’s props, you need to ensure that each component
      instance gets its own selector instance (see
      <a
        href="https://github.com/reduxjs/reselect#accessing-react-props-in-selectors"
        >here</a
      >
      for a more thorough explanation of why this is necessary):
    </p>
    <pre class="jsx"><code>import React, { useMemo } from &#39;react&#39;
import { useSelector } from &#39;react-redux&#39;
import { createSelector } from &#39;reselect&#39;

const makeSelectCompletedTodosCount = () =&gt;
  createSelector(
    (state) =&gt; state.todos,
    (_, completed) =&gt; completed,
    (todos, completed) =&gt;
      todos.filter((todo) =&gt; todo.completed === completed).length
  )

export const CompletedTodosCount = ({ completed }) =&gt; {
  const selectCompletedTodosCount = useMemo(makeSelectCompletedTodosCount, [])

  const matchingCount = useSelector((state) =&gt;
    selectCompletedTodosCount(state, completed)
  )

  return &lt;div&gt;{matchingCount}&lt;/div&gt;
}

export const App = () =&gt; {
  return (
    &lt;&gt;
      &lt;span&gt;Number of done todos:&lt;/span&gt;
      &lt;CompletedTodosCount completed={true} /&gt;
      &lt;span&gt;Number of unfinished todos:&lt;/span&gt;
      &lt;CompletedTodosCount completed={false} /&gt;
    &lt;/&gt;
  )
}</code></pre>
    <h2 id="usedispatch"><code>useDispatch()</code></h2>
    <div class="sourceCode" id="cb9">
      <pre
        class="sourceCode js"
      ><code class="sourceCode javascript"><a class="sourceLine" id="cb9-1" title="1"><span class="kw">const</span> dispatch <span class="op">=</span> <span class="at">useDispatch</span>()</a></code></pre>
    </div>
    <p>
      This hook returns a reference to the <code>dispatch</code> function from
      the Redux store. You may use it to dispatch actions as needed.
    </p>
    <h4 id="examples">Examples</h4>
    <pre class="jsx"><code>import React from &#39;react&#39;
import { useDispatch } from &#39;react-redux&#39;

export const CounterComponent = ({ value }) =&gt; {
  const dispatch = useDispatch()

  return (
    &lt;div&gt;
      &lt;span&gt;{value}&lt;/span&gt;
      &lt;button onClick={() =&gt; dispatch({ type: &#39;increment-counter&#39; })}&gt;
        Increment counter
      &lt;/button&gt;
    &lt;/div&gt;
  )
}</code></pre>
    <p>
      When passing a callback using <code>dispatch</code> to a child component,
      you may sometimes want to memoize it with
      <a href="https://reactjs.org/docs/hooks-reference.html#usecallback"
        ><code>useCallback</code></a
      >. <em>If</em> the child component is trying to optimize render behavior
      using <code>React.memo()</code> or similar, this avoids unnecessary
      rendering of child components due to the changed callback reference.
    </p>
    <pre class="jsx"><code>import React, { useCallback } from &#39;react&#39;
import { useDispatch } from &#39;react-redux&#39;

export const CounterComponent = ({ value }) =&gt; {
  const dispatch = useDispatch()
  const incrementCounter = useCallback(
    () =&gt; dispatch({ type: &#39;increment-counter&#39; }),
    [dispatch]
  )

  return (
    &lt;div&gt;
      &lt;span&gt;{value}&lt;/span&gt;
      &lt;MyIncrementButton onIncrement={incrementCounter} /&gt;
    &lt;/div&gt;
  )
}

export const MyIncrementButton = React.memo(({ onIncrement }) =&gt; (
  &lt;button onClick={onIncrement}&gt;Increment counter&lt;/button&gt;
))</code></pre>
    <p>:::info</p>
    <p>
      The <code>dispatch</code> function reference will be stable as long as the
      same store instance is being passed to the <code>&lt;Provider&gt;</code>.
      Normally, that store instance never changes in an application.
    </p>
    <p>
      However, the React hooks lint rules do not know that
      <code>dispatch</code> should be stable, and will warn that the
      <code>dispatch</code> variable should be added to dependency arrays for
      <code>useEffect</code> and <code>useCallback</code>. The simplest solution
      is to do just that:
    </p>
    <div class="sourceCode" id="cb12">
      <pre
        class="sourceCode js"
      ><code class="sourceCode javascript"><a class="sourceLine" id="cb12-1" title="1"><span class="im">export</span> <span class="kw">const</span> <span class="at">Todos</span>() <span class="op">=</span> () <span class="kw">=&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb12-2" title="2">  <span class="kw">const</span> dispatch <span class="op">=</span> <span class="at">useDispatch</span>()<span class="op">;</span></a>
<a class="sourceLine" id="cb12-3" title="3"></a>
<a class="sourceLine" id="cb12-4" title="4">  <span class="at">useEffect</span>(() <span class="kw">=&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb12-5" title="5">    <span class="at">dispatch</span>(<span class="at">fetchTodos</span>())</a>
<a class="sourceLine" id="cb12-6" title="6">  <span class="co">// highlight-start</span></a>
<a class="sourceLine" id="cb12-7" title="7">  <span class="co">// Safe to add dispatch to the dependencies array</span></a>
<a class="sourceLine" id="cb12-8" title="8">  <span class="op">},</span> [dispatch])</a>
<a class="sourceLine" id="cb12-9" title="9">  <span class="co">// highlight-end</span></a>
<a class="sourceLine" id="cb12-10" title="10"><span class="op">}</span></a>
<a class="sourceLine" id="cb12-11" title="11"></a>
<a class="sourceLine" id="cb12-12" title="12"><span class="op">:::</span></a>
<a class="sourceLine" id="cb12-13" title="13"></a>
<a class="sourceLine" id="cb12-14" title="14">## <span class="vs">`useStore()`</span></a>
<a class="sourceLine" id="cb12-15" title="15"></a>
<a class="sourceLine" id="cb12-16" title="16"><span class="vs">```js</span></a>
<a class="sourceLine" id="cb12-17" title="17"><span class="vs">const store = useStore()</span></a>
<a class="sourceLine" id="cb12-18" title="18"><span class="vs">```</span></a>
<a class="sourceLine" id="cb12-19" title="19"></a>
<a class="sourceLine" id="cb12-20" title="20">This hook returns a reference to the same Redux store that was passed <span class="kw">in</span> to the <span class="vs">`&lt;Provider&gt;`</span> <span class="va">component</span>.</a>
<a class="sourceLine" id="cb12-21" title="21"></a>
<a class="sourceLine" id="cb12-22" title="22">This hook should probably not be used <span class="va">frequently</span>. <span class="at">Prefer</span> <span class="vs">`useSelector()`</span> <span class="im">as</span> your primary <span class="va">choice</span>. <span class="at">However</span><span class="op">,</span> <span class="kw">this</span> may be useful <span class="cf">for</span> less common scenarios that <span class="cf">do</span> require access to the store<span class="op">,</span> such <span class="im">as</span> replacing <span class="va">reducers</span>.</a>
<a class="sourceLine" id="cb12-23" title="23"></a>
<a class="sourceLine" id="cb12-24" title="24">#### Examples</a>
<a class="sourceLine" id="cb12-25" title="25"></a>
<a class="sourceLine" id="cb12-26" title="26"><span class="vs">```jsx</span></a>
<a class="sourceLine" id="cb12-27" title="27"><span class="vs">import React from &#39;react&#39;</span></a>
<a class="sourceLine" id="cb12-28" title="28"><span class="vs">import { useStore } from &#39;react-redux&#39;</span></a>
<a class="sourceLine" id="cb12-29" title="29"></a>
<a class="sourceLine" id="cb12-30" title="30"><span class="vs">export const CounterComponent = ({ value }) =&gt; {</span></a>
<a class="sourceLine" id="cb12-31" title="31"><span class="vs">  const store = useStore()</span></a>
<a class="sourceLine" id="cb12-32" title="32"></a>
<a class="sourceLine" id="cb12-33" title="33"><span class="vs">  // EXAMPLE ONLY! Do not do this in a real app.</span></a>
<a class="sourceLine" id="cb12-34" title="34"><span class="vs">  // The component will not automatically update if the store state changes</span></a>
<a class="sourceLine" id="cb12-35" title="35"><span class="vs">  return &lt;div&gt;{store.getState()}&lt;/div&gt;</span></a>
<a class="sourceLine" id="cb12-36" title="36"><span class="vs">}</span></a>
<a class="sourceLine" id="cb12-37" title="37"><span class="vs">```</span></a>
<a class="sourceLine" id="cb12-38" title="38"></a>
<a class="sourceLine" id="cb12-39" title="39">## Custom context</a>
<a class="sourceLine" id="cb12-40" title="40"></a>
<a class="sourceLine" id="cb12-41" title="41">The <span class="vs">`&lt;Provider&gt;`</span> component allows you to specify an alternate context via the <span class="vs">`context`</span> <span class="va">prop</span>. <span class="at">This</span> is useful <span class="cf">if</span> you<span class="st">&#39;re building a complex reusable component, and you don&#39;</span>t want your store to collide <span class="cf">with</span> any Redux store your consumers<span class="st">&#39; applications might use.</span></a>
<a class="sourceLine" id="cb12-42" title="42"></a>
<a class="sourceLine" id="cb12-43" title="43">To access an alternate context via the hooks API<span class="op">,</span> use the hook creator functions<span class="op">:</span></a>
<a class="sourceLine" id="cb12-44" title="44"></a>
<a class="sourceLine" id="cb12-45" title="45"><span class="vs">```js</span></a>
<a class="sourceLine" id="cb12-46" title="46"><span class="vs">import React from &#39;react&#39;</span></a>
<a class="sourceLine" id="cb12-47" title="47"><span class="vs">import {</span></a>
<a class="sourceLine" id="cb12-48" title="48"><span class="vs">  Provider,</span></a>
<a class="sourceLine" id="cb12-49" title="49"><span class="vs">  createStoreHook,</span></a>
<a class="sourceLine" id="cb12-50" title="50"><span class="vs">  createDispatchHook,</span></a>
<a class="sourceLine" id="cb12-51" title="51"><span class="vs">  createSelectorHook</span></a>
<a class="sourceLine" id="cb12-52" title="52"><span class="vs">} from &#39;react-redux&#39;</span></a>
<a class="sourceLine" id="cb12-53" title="53"></a>
<a class="sourceLine" id="cb12-54" title="54"><span class="vs">const MyContext = React.createContext(null)</span></a>
<a class="sourceLine" id="cb12-55" title="55"></a>
<a class="sourceLine" id="cb12-56" title="56"><span class="vs">// Export your custom hooks if you wish to use them in other files.</span></a>
<a class="sourceLine" id="cb12-57" title="57"><span class="vs">export const useStore = createStoreHook(MyContext)</span></a>
<a class="sourceLine" id="cb12-58" title="58"><span class="vs">export const useDispatch = createDispatchHook(MyContext)</span></a>
<a class="sourceLine" id="cb12-59" title="59"><span class="vs">export const useSelector = createSelectorHook(MyContext)</span></a>
<a class="sourceLine" id="cb12-60" title="60"></a>
<a class="sourceLine" id="cb12-61" title="61"><span class="vs">const myStore = createStore(rootReducer)</span></a>
<a class="sourceLine" id="cb12-62" title="62"></a>
<a class="sourceLine" id="cb12-63" title="63"><span class="vs">export function MyProvider({ children }) {</span></a>
<a class="sourceLine" id="cb12-64" title="64"><span class="vs">  return (</span></a>
<a class="sourceLine" id="cb12-65" title="65"><span class="vs">    &lt;Provider context={MyContext} store={myStore}&gt;</span></a>
<a class="sourceLine" id="cb12-66" title="66"><span class="vs">      {children}</span></a>
<a class="sourceLine" id="cb12-67" title="67"><span class="vs">    &lt;/Provider&gt;</span></a>
<a class="sourceLine" id="cb12-68" title="68"><span class="vs">  )</span></a>
<a class="sourceLine" id="cb12-69" title="69"><span class="vs">}</span></a>
<a class="sourceLine" id="cb12-70" title="70"><span class="vs">```</span></a>
<a class="sourceLine" id="cb12-71" title="71"></a>
<a class="sourceLine" id="cb12-72" title="72">## Usage Warnings</a>
<a class="sourceLine" id="cb12-73" title="73"></a>
<a class="sourceLine" id="cb12-74" title="74">### Stale Props and <span class="st">&quot;Zombie Children&quot;</span></a>
<a class="sourceLine" id="cb12-75" title="75"></a>
<a class="sourceLine" id="cb12-76" title="76"><span class="op">:::</span>info</a>
<a class="sourceLine" id="cb12-77" title="77"></a>
<a class="sourceLine" id="cb12-78" title="78">The React<span class="op">-</span>Redux hooks API has been production<span class="op">-</span>ready since we released it <span class="kw">in</span> <span class="va">v7</span>.<span class="fl">1.0</span><span class="op">,</span> and <span class="op">**</span>we recommend using the hooks API <span class="im">as</span> the <span class="im">default</span> approach <span class="kw">in</span> your components<span class="op">**</span>. <span class="at">However</span><span class="op">,</span> there are a couple <span class="kw">of</span> edge cases that can occur<span class="op">,</span> and <span class="op">**</span>we<span class="st">&#39;re documenting those so that you can be aware of them**.</span></a>
<a class="sourceLine" id="cb12-79" title="79"></a>
<a class="sourceLine" id="cb12-80" title="80"><span class="op">:::</span></a>
<a class="sourceLine" id="cb12-81" title="81"></a>
<a class="sourceLine" id="cb12-82" title="82">One <span class="kw">of</span> the most difficult aspects <span class="kw">of</span> React Redux<span class="st">&#39;s implementation is ensuring that if your `mapStateToProps` function is defined as `(state, ownProps)`, it will be called with the &quot;latest&quot; props every time. Up through version 4, there were recurring bugs reported involving edge case situations, such as errors thrown from a `mapState` function for a list item whose data had just been deleted.</span></a>
<a class="sourceLine" id="cb12-83" title="83"></a>
<a class="sourceLine" id="cb12-84" title="84">Starting <span class="cf">with</span> version <span class="dv">5</span><span class="op">,</span> React Redux has attempted to guarantee that consistency <span class="cf">with</span> <span class="vs">`ownProps`</span>. <span class="at">In</span> version <span class="dv">7</span><span class="op">,</span> that is implemented using a custom <span class="vs">`Subscription`</span> <span class="kw">class</span> internally <span class="kw">in</span> <span class="vs">`connect()`</span><span class="op">,</span> which forms a nested <span class="va">hierarchy</span>. <span class="at">This</span> ensures that connected components lower <span class="kw">in</span> the tree will only receive store update notifications once the nearest connected ancestor has been <span class="va">updated</span>. <span class="at">However</span><span class="op">,</span> <span class="kw">this</span> relies on each <span class="vs">`connect()`</span> instance overriding part <span class="kw">of</span> the internal React context<span class="op">,</span> supplying its own unique <span class="vs">`Subscription`</span> instance to form that nesting<span class="op">,</span> and rendering the <span class="vs">`&lt;ReactReduxContext.Provider&gt;`</span> <span class="cf">with</span> that <span class="kw">new</span> context <span class="va">value</span>.</a>
<a class="sourceLine" id="cb12-85" title="85"></a>
<a class="sourceLine" id="cb12-86" title="86">With hooks<span class="op">,</span> there is no way to render a context provider<span class="op">,</span> which means there<span class="st">&#39;s also no nested hierarchy of subscriptions. Because of this, the &quot;stale props&quot; and &quot;zombie child&quot; issues may potentially re-occur in an app that relies on using hooks instead of `connect()`.</span></a>
<a class="sourceLine" id="cb12-87" title="87"></a>
<a class="sourceLine" id="cb12-88" title="88">Specifically<span class="op">,</span> <span class="st">&quot;stale props&quot;</span> means any <span class="cf">case</span> where<span class="op">:</span></a>
<a class="sourceLine" id="cb12-89" title="89"></a>
<a class="sourceLine" id="cb12-90" title="90"><span class="op">-</span> a selector <span class="kw">function</span> relies on <span class="kw">this</span> component<span class="st">&#39;s props to extract data</span></a>
<a class="sourceLine" id="cb12-91" title="91"><span class="op">-</span> a parent component _would_ re<span class="op">-</span>render and pass down <span class="kw">new</span> props <span class="im">as</span> a result <span class="kw">of</span> an action</a>
<a class="sourceLine" id="cb12-92" title="92"><span class="op">-</span> but <span class="kw">this</span> component<span class="st">&#39;s selector function executes before this component has had a chance to re-render with those new props</span></a>
<a class="sourceLine" id="cb12-93" title="93"></a>
<a class="sourceLine" id="cb12-94" title="94">Depending on what props were used and what the current store state is<span class="op">,</span> <span class="kw">this</span> _may_ result <span class="kw">in</span> incorrect data being returned <span class="im">from</span> the selector<span class="op">,</span> or even an error being <span class="va">thrown</span>.</a>
<a class="sourceLine" id="cb12-95" title="95"></a>
<a class="sourceLine" id="cb12-96" title="96"><span class="st">&quot;Zombie child&quot;</span> refers specifically to the <span class="cf">case</span> where<span class="op">:</span></a>
<a class="sourceLine" id="cb12-97" title="97"></a>
<a class="sourceLine" id="cb12-98" title="98"><span class="op">-</span> Multiple nested connected components are mounted <span class="kw">in</span> a first pass<span class="op">,</span> causing a child component to subscribe to the store before its parent</a>
<a class="sourceLine" id="cb12-99" title="99"><span class="op">-</span> An action is dispatched that deletes data <span class="im">from</span> the store<span class="op">,</span> such <span class="im">as</span> a todo item</a>
<a class="sourceLine" id="cb12-100" title="100"><span class="op">-</span> The parent component _would_ stop rendering that child <span class="im">as</span> a result</a>
<a class="sourceLine" id="cb12-101" title="101"><span class="op">-</span> However<span class="op">,</span> because the child subscribed first<span class="op">,</span> its subscription runs before the parent stops rendering <span class="va">it</span>. <span class="at">When</span> it reads a value <span class="im">from</span> the store based on props<span class="op">,</span> that data no longer exists<span class="op">,</span> and <span class="cf">if</span> the extraction logic is not careful<span class="op">,</span> <span class="kw">this</span> may result <span class="kw">in</span> an error being <span class="va">thrown</span>.</a>
<a class="sourceLine" id="cb12-102" title="102"></a>
<a class="sourceLine" id="cb12-103" title="103"><span class="vs">`useSelector()`</span> tries to deal <span class="cf">with</span> <span class="kw">this</span> by catching all errors that are thrown when the selector is executed due to a store <span class="at">update</span> (but not when it is executed during rendering). <span class="at">When</span> an error occurs<span class="op">,</span> the component will be forced to render<span class="op">,</span> at which point the selector is executed <span class="va">again</span>. <span class="at">This</span> works <span class="im">as</span> long <span class="im">as</span> the selector is a pure <span class="kw">function</span> and you <span class="cf">do</span> not depend on the selector throwing <span class="va">errors</span>.</a>
<a class="sourceLine" id="cb12-104" title="104"></a>
<a class="sourceLine" id="cb12-105" title="105">If you prefer to deal <span class="cf">with</span> <span class="kw">this</span> issue yourself<span class="op">,</span> here are some possible options <span class="cf">for</span> avoiding these problems altogether <span class="cf">with</span> <span class="vs">`useSelector()`</span><span class="op">:</span></a>
<a class="sourceLine" id="cb12-106" title="106"></a>
<a class="sourceLine" id="cb12-107" title="107"><span class="op">-</span> Don<span class="st">&#39;t rely on props in your selector function for extracting data</span></a>
<a class="sourceLine" id="cb12-108" title="108"><span class="op">-</span> In cases where you <span class="cf">do</span> rely on props <span class="kw">in</span> your selector <span class="kw">function</span> _and_ those props may change over time<span class="op">,</span> _or_ the data you<span class="st">&#39;re extracting may be based on items that can be deleted, try writing the selector functions defensively. Don&#39;</span>t just reach straight into <span class="vs">`state.todos[props.id].name`</span> <span class="op">-</span> read <span class="vs">`state.todos[props.id]`</span> first<span class="op">,</span> and verify that it exists before trying to read <span class="vs">`todo.name`</span>.</a>
<a class="sourceLine" id="cb12-109" title="109"><span class="op">-</span> Because <span class="vs">`connect`</span> adds the necessary <span class="vs">`Subscription`</span> to the context provider and delays evaluating child subscriptions until the connected component has re<span class="op">-</span>rendered<span class="op">,</span> putting a connected component <span class="kw">in</span> the component tree just above the component using <span class="vs">`useSelector`</span> will prevent these issues <span class="im">as</span> long <span class="im">as</span> the connected component gets re<span class="op">-</span>rendered due to the same store update <span class="im">as</span> the hooks <span class="va">component</span>.</a>
<a class="sourceLine" id="cb12-110" title="110"></a>
<a class="sourceLine" id="cb12-111" title="111"><span class="op">:::</span>info</a>
<a class="sourceLine" id="cb12-112" title="112"></a>
<a class="sourceLine" id="cb12-113" title="113">For a longer description <span class="kw">of</span> these scenarios<span class="op">,</span> see<span class="op">:</span></a>
<a class="sourceLine" id="cb12-114" title="114"></a>
<a class="sourceLine" id="cb12-115" title="115"><span class="op">-</span> [<span class="st">&quot;Stale props and zombie children in Redux&quot;</span> by Kai Hao](https<span class="op">:</span><span class="co">//kaihao.dev/posts/Stale-props-and-zombie-children-in-Redux)</span></a>
<a class="sourceLine" id="cb12-116" title="116"><span class="op">-</span> [<span class="kw">this</span> chat log that describes the problems <span class="kw">in</span> more detail](https<span class="op">:</span><span class="co">//gist.github.com/markerikson/faac6ae4aca7b82a058e13216a7888ec)</span></a>
<a class="sourceLine" id="cb12-117" title="117"><span class="op">-</span> [issue #<span class="dv">1179</span>](https<span class="op">:</span><span class="co">//github.com/reduxjs/react-redux/issues/1179)</span></a>
<a class="sourceLine" id="cb12-118" title="118"></a>
<a class="sourceLine" id="cb12-119" title="119"><span class="op">:::</span></a>
<a class="sourceLine" id="cb12-120" title="120"></a>
<a class="sourceLine" id="cb12-121" title="121">### Performance</a>
<a class="sourceLine" id="cb12-122" title="122"></a>
<a class="sourceLine" id="cb12-123" title="123">As mentioned earlier<span class="op">,</span> by <span class="im">default</span> <span class="vs">`useSelector()`</span> will <span class="cf">do</span> a reference equality comparison <span class="kw">of</span> the selected value when running the selector <span class="kw">function</span> after an action is dispatched<span class="op">,</span> and will only cause the component to re<span class="op">-</span>render <span class="cf">if</span> the selected value <span class="va">changed</span>. <span class="at">However</span><span class="op">,</span> unlike <span class="vs">`connect()`</span><span class="op">,</span> <span class="vs">`useSelector()`</span> does not prevent the component <span class="im">from</span> re<span class="op">-</span>rendering due to its parent re<span class="op">-</span>rendering<span class="op">,</span> even <span class="cf">if</span> the component<span class="st">&#39;s props did not change.</span></a>
<a class="sourceLine" id="cb12-124" title="124"></a>
<a class="sourceLine" id="cb12-125" title="125">If further performance optimizations are necessary<span class="op">,</span> you may consider wrapping your <span class="kw">function</span> component <span class="kw">in</span> <span class="vs">`React.memo()`</span><span class="op">:</span></a>
<a class="sourceLine" id="cb12-126" title="126"></a>
<a class="sourceLine" id="cb12-127" title="127"><span class="vs">```jsx</span></a>
<a class="sourceLine" id="cb12-128" title="128"><span class="vs">const CounterComponent = ({ name }) =&gt; {</span></a>
<a class="sourceLine" id="cb12-129" title="129"><span class="vs">  const counter = useSelector(state =&gt; state.counter)</span></a>
<a class="sourceLine" id="cb12-130" title="130"><span class="vs">  return (</span></a>
<a class="sourceLine" id="cb12-131" title="131"><span class="vs">    &lt;div&gt;</span></a>
<a class="sourceLine" id="cb12-132" title="132"><span class="vs">      {name}: {counter}</span></a>
<a class="sourceLine" id="cb12-133" title="133"><span class="vs">    &lt;/div&gt;</span></a>
<a class="sourceLine" id="cb12-134" title="134"><span class="vs">  )</span></a>
<a class="sourceLine" id="cb12-135" title="135"><span class="vs">}</span></a>
<a class="sourceLine" id="cb12-136" title="136"></a>
<a class="sourceLine" id="cb12-137" title="137"><span class="vs">export const MemoizedCounterComponent = React.memo(CounterComponent)</span></a>
<a class="sourceLine" id="cb12-138" title="138"><span class="vs">```</span></a>
<a class="sourceLine" id="cb12-139" title="139"></a>
<a class="sourceLine" id="cb12-140" title="140">## Hooks Recipes</a>
<a class="sourceLine" id="cb12-141" title="141"></a>
<a class="sourceLine" id="cb12-142" title="142">We<span class="st">&#39;ve pared down our hooks API from the original alpha release, focusing on a more minimal set of API primitives.</span></a>
<a class="sourceLine" id="cb12-143" title="143">However<span class="op">,</span> you may still wish to use some <span class="kw">of</span> the approaches we tried <span class="kw">in</span> your own <span class="va">apps</span>. <span class="at">These</span> examples should be ready</a>
<a class="sourceLine" id="cb12-144" title="144">to copy and paste into your own <span class="va">codebase</span>.</a>
<a class="sourceLine" id="cb12-145" title="145"></a>
<a class="sourceLine" id="cb12-146" title="146">### Recipe<span class="op">:</span> <span class="vs">`useActions()`</span></a>
<a class="sourceLine" id="cb12-147" title="147"></a>
<a class="sourceLine" id="cb12-148" title="148">This hook was <span class="kw">in</span> our original alpha release<span class="op">,</span> but removed <span class="kw">in</span> <span class="vs">`v7.1.0-alpha.4`</span><span class="op">,</span> based on [Dan Abramov<span class="st">&#39;s suggestion](https://github.com/reduxjs/react-redux/issues/1252#issuecomment-488160930).</span></a>
<a class="sourceLine" id="cb12-149" title="149">That suggestion was based on <span class="st">&quot;binding action creators&quot;</span> not being <span class="im">as</span> useful <span class="kw">in</span> a hooks<span class="op">-</span>based use <span class="cf">case</span><span class="op">,</span> and causing too</a>
<a class="sourceLine" id="cb12-150" title="150">much conceptual overhead and syntactic <span class="va">complexity</span>.</a>
<a class="sourceLine" id="cb12-151" title="151"></a>
<a class="sourceLine" id="cb12-152" title="152">You should probably prefer to call the [<span class="vs">`useDispatch`</span>](#usedispatch) hook <span class="kw">in</span> your components to retrieve a reference to <span class="vs">`dispatch`</span><span class="op">,</span></a>
<a class="sourceLine" id="cb12-153" title="153">and manually call <span class="vs">`dispatch(someActionCreator())`</span> <span class="kw">in</span> callbacks and effects <span class="im">as</span> <span class="va">needed</span>. <span class="at">You</span> may also use the Redux</a>
<a class="sourceLine" id="cb12-154" title="154">[<span class="vs">`bindActionCreators`</span>](https<span class="op">:</span><span class="co">//redux.js.org/api/bindactioncreators) function in your own code to bind action creators,</span></a>
<a class="sourceLine" id="cb12-155" title="155">or <span class="st">&quot;manually&quot;</span> bind them like <span class="vs">`const boundAddTodo = (text) =&gt; dispatch(addTodo(text))`</span>.</a>
<a class="sourceLine" id="cb12-156" title="156"></a>
<a class="sourceLine" id="cb12-157" title="157">However<span class="op">,</span> <span class="cf">if</span> you<span class="st">&#39;d like to still use this hook yourself, here&#39;</span>s a copy<span class="op">-</span>pastable version that supports passing <span class="kw">in</span> action</a>
<a class="sourceLine" id="cb12-158" title="158">creators <span class="im">as</span> a single <span class="kw">function</span><span class="op">,</span> an array<span class="op">,</span> or an <span class="va">object</span>.</a>
<a class="sourceLine" id="cb12-159" title="159"></a>
<a class="sourceLine" id="cb12-160" title="160"><span class="vs">```js</span></a>
<a class="sourceLine" id="cb12-161" title="161"><span class="vs">import { bindActionCreators } from &#39;redux&#39;</span></a>
<a class="sourceLine" id="cb12-162" title="162"><span class="vs">import { useDispatch } from &#39;react-redux&#39;</span></a>
<a class="sourceLine" id="cb12-163" title="163"><span class="vs">import { useMemo } from &#39;react&#39;</span></a>
<a class="sourceLine" id="cb12-164" title="164"></a>
<a class="sourceLine" id="cb12-165" title="165"><span class="vs">export function useActions(actions, deps) {</span></a>
<a class="sourceLine" id="cb12-166" title="166"><span class="vs">  const dispatch = useDispatch()</span></a>
<a class="sourceLine" id="cb12-167" title="167"><span class="vs">  return useMemo(</span></a>
<a class="sourceLine" id="cb12-168" title="168"><span class="vs">    () =&gt; {</span></a>
<a class="sourceLine" id="cb12-169" title="169"><span class="vs">      if (Array.isArray(actions)) {</span></a>
<a class="sourceLine" id="cb12-170" title="170"><span class="vs">        return actions.map(a =&gt; bindActionCreators(a, dispatch))</span></a>
<a class="sourceLine" id="cb12-171" title="171"><span class="vs">      }</span></a>
<a class="sourceLine" id="cb12-172" title="172"><span class="vs">      return bindActionCreators(actions, dispatch)</span></a>
<a class="sourceLine" id="cb12-173" title="173"><span class="vs">    },</span></a>
<a class="sourceLine" id="cb12-174" title="174"><span class="vs">    deps ? [dispatch, ...deps] : [dispatch]</span></a>
<a class="sourceLine" id="cb12-175" title="175"><span class="vs">  )</span></a>
<a class="sourceLine" id="cb12-176" title="176"><span class="vs">}</span></a>
<a class="sourceLine" id="cb12-177" title="177"><span class="vs">```</span></a>
<a class="sourceLine" id="cb12-178" title="178"></a>
<a class="sourceLine" id="cb12-179" title="179">### Recipe<span class="op">:</span> <span class="vs">`useShallowEqualSelector()`</span></a>
<a class="sourceLine" id="cb12-180" title="180"></a>
<a class="sourceLine" id="cb12-181" title="181"><span class="vs">```js</span></a>
<a class="sourceLine" id="cb12-182" title="182"><span class="vs">import { useSelector, shallowEqual } from &#39;react-redux&#39;</span></a>
<a class="sourceLine" id="cb12-183" title="183"></a>
<a class="sourceLine" id="cb12-184" title="184"><span class="vs">export function useShallowEqualSelector(selector) {</span></a>
<a class="sourceLine" id="cb12-185" title="185"><span class="vs">  return useSelector(selector, shallowEqual)</span></a>
<a class="sourceLine" id="cb12-186" title="186"><span class="vs">}</span></a>
<a class="sourceLine" id="cb12-187" title="187"><span class="vs">```</span></a>
<a class="sourceLine" id="cb12-188" title="188"></a>
<a class="sourceLine" id="cb12-189" title="189">### Additional considerations when using hooks</a>
<a class="sourceLine" id="cb12-190" title="190"></a>
<a class="sourceLine" id="cb12-191" title="191">There are some architectural trade offs to take into consideration when deciding whether to use hooks or <span class="va">not</span>. <span class="at">Mark</span> Erikson summarizes these nicely <span class="kw">in</span> his two blog posts [Thoughts on React Hooks<span class="op">,</span> Redux<span class="op">,</span> and Separation <span class="kw">of</span> Concerns](https<span class="op">:</span><span class="co">//blog.isquaredsoftware.com/2019/07/blogged-answers-thoughts-on-hooks/) and [Hooks, HOCs, and Tradeoffs](https://blog.isquaredsoftware.com/2019/09/presentation-hooks-hocs-tradeoffs/).</span></a></code></pre>
    </div>
  </body>
</html>
