<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
  <head>
    <meta charset="utf-8" />
    <meta name="generator" content="pandoc" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, user-scalable=yes"
    />
    <title>notes1</title>
    <style type="text/css">
      code {
        white-space: pre-wrap;
      }
      span.smallcaps {
        font-variant: small-caps;
      }
      span.underline {
        text-decoration: underline;
      }
      div.column {
        display: inline-block;
        vertical-align: top;
        width: 50%;
      }
    </style>
  </head>
  <body>
    <h1
      id="objective-1---explain-what-redux-is-and-the-problem-it-solves-web43---3.2"
    >
      Objective 1 - explain what Redux is and the problem it solves: WEB43 - 3.2
    </h1>
    <blockquote>
      <p>
        Redux is a predictable state management library for JavaScript
        applications and is the most popular State container for React
        applications. By now, we have discovered that building out applications
        using React requires a lot of forethought to give an application
        scalability. Specifically, we have noticed some complications around the
        area of state-management. You may have asked yourself a question like
        “Which of my components should have state vs. which of my components
        should just be a way to present some DOM elements?”
      </p>
    </blockquote>
    <h2 id="overview">Overview</h2>
    <p>
      Redux is a predictable state management library for JavaScript
      applications and is the most popular State container for React
      applications. By now, we have discovered that building out applications
      using React requires a lot of forethought to give an application
      scalability. Specifically, we have noticed some complications around the
      area of state-management. You may have asked yourself a question like
      <em
        >“Which of my components should have state vs. which of my components
        should just be a way to present some DOM elements?”</em
      >
    </p>
    <p>
      Luckily you’re not alone in this dilemma. In fact, the Facebook team that
      built React in the first place noticed that managing state could become a
      nightmare at scale were they only to use component state. So, they built a
      pattern, and said, “everyone here at Facebook is going to write code after
      this pattern.” This way, they could eliminate many of the problems that
      unwieldy state-full components could surface. That pattern was called
      <code>Flux</code>
      <a href="https://facebook.github.io/flux/docs/overview.html"
        >link to docs (Links to an external site.)</a
      >, and it’s primary use case was to add some stringency to the React
      ecosystem because by itself, React is very unopinionated in how one should
      be designing their application and managing state.
    </p>
    <p>
      Flux was great, but developers had a hard time with implementation because
      the pattern presented a few other problems. Because of this, (and around
      the same time that React was becoming so popular)
      <a href="https://github.com/gaearon"
        >Dan Abramov (Links to an external site.)</a
      >
      built out a ‘Time-traveling’ approach to debug an application. This method
      eventually became known as Redux. Dan wanted to be able to go back in time
      to see when/where the state had changed in his application, and to do
      that, he ended up creating one of the most popular state-management
      libraries known to React Developers today.
    </p>
    <p>
      Redux is a small, light-weight state container for use when building
      JavaScript applications. Remember, Redux has nothing to do with React
      other than the fact that many developers use them together. The core
      concepts/principles of Redux are 3 fold:
    </p>
    <h4 id="the-store">The Store</h4>
    <blockquote>
      <p>
        Everything that changes within your application is represented<br />
        by a single JavaScript Object known as the store. The store<br />
        contains our state for our application.
      </p>
    </blockquote>
    <h4 id="application-state-is-immutable">Application state is Immutable</h4>
    <blockquote>
      <p>
        When the application state changes, we clone the state object, modify
        the clone, and replace the original state with the new copy. We never
        mutate the original object, and we never write to our store object.
      </p>
    </blockquote>
    <h4 id="pure-functions-change-our-state">
      Pure functions change our state
    </h4>
    <blockquote>
      <p>
        Given the same input, a pure function returns the same output every
        time. All functions (reducers) in Redux must be pure functions. Meaning
        they take in some state and a description of what changes took place and
        return a copy of our state.
      </p>
    </blockquote>
    <p>
      Redux is pretty simple at its core, the complications with Redux arise
      when we try and implement it within a React application. Usually, these
      issues are because there is some new syntax, and it’s just a matter of
      time spent learning to sort them out.
    </p>
    <h2 id="follow-along">Follow Along</h2>
    <p>
      Watch the first 4 videos in
      <a
        href="https://egghead.io/lessons/react-redux-the-single-immutable-state-tree"
        >this series (Links to an external site.)</a
      >
      and try to wrap your head around how this would be useful in a React
      application. Think of your projects that you’ve built in React up until
      this point. What types of problems would Redux have solved in those
      projects if any?
    </p>
    <h2 id="challenge">Challenge</h2>
    <p>
      Write your thoughts on why Redux exists and at least one reason to use it
      as well as one reason to not use it.
    </p>
    <p>
      <a
        href="https://lambdaschool.instructure.com/courses/1218/pages/objective-1-explain-what-redux-is-and-the-problem-it-solves?module_item_id=597488"
        >Source</a
      >
    </p>
    <h1
      id="objective-2---create-a-redux-store-and-connect-it-to-a-react-application-web43---3.2"
    >
      Objective 2 - create a Redux Store and connect it to a React application:
      WEB43 - 3.2
    </h1>
    <blockquote>
      <p>
        In this section, we’ll learn how to create the Redux Store and how to
        use a library called react-redux to connect our React application to the
        Store. Because Redux is a standalone library, (meaning it can be used on
        its own or with another library/framework for state-management and data
        flow) we have to use a second helper package that will enable us to
        string together Redux within a React application. That package is called
        React-Redux (Links to an external site.). Some more documentation and
        information lives here (Links to an external site.). The packages React
        and Redux are entirely separate, as quoted in the Redux documentation.
      </p>
    </blockquote>
    <h2 id="overview-1">Overview</h2>
    <p>
      In this section, we’ll learn how to create the <em>Redux Store</em> and
      how to use a library called <code>react-redux</code> to connect our React
      application to the <em>Store</em>. Because Redux is a standalone
      library,<br />
      (meaning it can be used on its own or with another library/framework for
      state-management and data flow) we have to use a second helper package
      that will enable us to string together Redux within a React application.
      That package is called
      <a href="https://github.com/reduxjs/react-redux"
        >React-Redux (Links to an external site.)</a
      >. Some more documentation and information lives
      <a href="http://redux.js.org/basics/usage-with-react"
        >here (Links to an external site.)</a
      >. The packages <code>React</code> and <code>Redux</code> are entirely
      separate, as quoted in the Redux documentation.
    </p>
    <blockquote>
      <p>
        From the very beginning, we need to stress that Redux has no relation to
        React. You can write Redux apps with React, Angular, Ember, jQuery, or
        vanilla JavaScript.
      </p>
    </blockquote>
    <h2 id="follow-along-1">Follow Along</h2>
    <p>
      The first step we’re going to take to enable Redux within a React
      application is to install it. This process assumes you’ve used Create
      React App to boilerplate out a React application.
    </p>
    <pre><code>npm install react-redux redux</code></pre>
    <p>
      Now that we have <code>redux</code> and
      <code>react-redux</code> installed, let’s learn how to set it up within
      our application. We will use the <code>createStore</code> function from
      <code>redux</code>, so let’s import that first.
    </p>
    <pre><code>import { createStore } from &#39;redux&#39;;</code></pre>
    <p>
      <code>createStore</code> will take in a single reducer that represents the
      state (data) of our application globally. We need to create a
      <code>store</code> variable, and use <code>createStore</code> to create
      the Redux store.
    </p>
    <pre><code>const store = createStore(reducer);</code></pre>
    <p>
      You’ll notice that we passed a reducer into <code>createStore</code>, but
      we don’t have a reducer yet. We’ll learn a lot more about reducers soon.
      For now, let’s create a function called <code>reducer</code> that returns
      an object representing our state.
    </p>
    <pre><code>function reducer() {
  return {
    title: &#39;Hello world! I\&#39;m in the Redux store!&#39;,
  }
}

const store = createStore(reducer);</code></pre>
    <p>
      Now that we have a store, we want to make our application aware of it. The
      way this works is that react-redux gives us a
      <code>&lt;Provider&gt;&lt;/Provider&gt;</code> component that wraps around
      our entire application. We will pass our newly created store to that
      component as a prop.
    </p>
    <p>
      Within our Root Component (usually <code>Index.js</code>), go ahead and
      import <code>Provider</code> from <code>react-redux</code>.
    </p>
    <pre><code>import { Provider } from &#39;react-redux&#39;;</code></pre>
    <p>
      Then, all we need to do is wrap our <code>&lt;App/&gt;</code> with the
      <code>&lt;Provider&gt;</code> component and pass a <code>store</code> prop
      set equal to the store we created. This will look like this:
    </p>
    <pre><code>&lt;Provider store={store}&gt;
  &lt;App/&gt;
&lt;/Provider&gt;</code></pre>
    <h2 id="challenge-1">Challenge</h2>
    <p>
      Let’s go ahead and take a peek at our application using the React Dev
      Tools now that we’ve wrapped it up in a Provider Component.
    </p>
    <p>
      Now, take the time to think about where and when you’ve done this before?
      Is there a package that we’ve used this same way? If so, which package is
      it? It is important to note that a large number of packages that we use in
      React are implemented this way.
    </p>
    <p>
      Write down a few thoughts on what you see, where you’ve seen similar
      patterns, etc, and send that to your PM.
    </p>
    <p>
      <a
        href="https://lambdaschool.instructure.com/courses/1218/pages/objective-2-create-a-redux-store-and-connect-it-to-a-react-application?module_item_id=597493"
        >Source</a
      >
    </p>
    <h1
      id="objective-3---use-the-connect-function-to-connect-react-components-to-the-redux-store-web43---3.2"
    >
      Objective 3 - use the connect function to connect React components to the
      Redux store: WEB43 - 3.2
    </h1>
    <blockquote>
      <p>
        Now that we have built a store to manage our state, we need to connect
        our components to that store. We can do so using the connect function,
        within the components themselves. We can also build a helper function
        within the component files to tell the connect function what pieces of
        state we want to access. This function is usually named mapStateToProps,
        and it will map pieces of our Redux state to the props of our component.
        Let’s try it out.
      </p>
    </blockquote>
    <h2 id="overview-2">Overview</h2>
    <p>
      Now that we have built a store to manage our state, we need to connect our
      components to that store. We can do so using the
      <code>connect</code> function, within the components themselves. We can
      also build a helper function within the component files to tell the
      <code>connect</code> function what pieces of state we want to access. This
      function is usually named <code>mapStateToProps</code>, and it will map
      pieces of our Redux state to the props of our component. Let’s try it out.
    </p>
    <h2 id="follow-along-2">Follow Along</h2>
    <p>
      Using the app you created earlier that has the redux store wired up,
      change the object you initially returned out of the reducer function to
      look like this:
    </p>
    <pre><code>{
  user: {
    name: &#39;Dustin&#39;
  },
  movies: [
    &#39;Star Wars&#39;,
    &#39;Lord of the Rings&#39;,
    &#39;Harry Potter&#39;
  ],
  todoList: [
    { task: &#39;Learn Redux&#39;, id: 0, completed: false }
  ],
  moviesToWatch: 13
}</code></pre>
    <p>
      Now create a component called <code>MovieList</code>. Next, we’ll take a
      look at the syntax we use to connect our React component to Redux, then
      we’ll talk about it. To start, import the <code>connect</code> function
      into your component:
    </p>
    <pre><code>import { connect } from &#39;react-redux&#39;;</code></pre>
    <p>
      Next, we use the <code>connect</code> function, where we export the
      component at the bottom of the file. We invoke <code>connect</code> twice
      (function currying). First with two arguments - a function and an object.
      Second with just the component we are trying to connect. For now, we’ll
      pass <code>null</code> and <code>{}</code> into the first invocation.
    </p>
    <pre><code>export default connect(null, {})(MovieList)</code></pre>
    <p>
      Now <code>MovieList</code> is connected to the store. Let’s write our
      <code>mapStateToProps</code> function now, to tell
      <code>connect</code> which pieces of our state we want to bring in to this
      component. This function takes in <code>state</code> as a parameter, then
      returns an object where the properties can be passed to props, and the
      values are retrieved from the store for our component.
    </p>
    <p>
      For a <code>MovieList</code> component, we probably only want to know
      about the <code>movies</code> array and the
      <code>moviesToWatch</code> number, <em>maybe</em> the
      <code>user</code> object. We’ll not worry about the <code>todoList</code>,
      since our component doesn’t need to know about that part of our state.
      Let’s bring those three pieces of our state into the component.
    </p>
    <pre><code>const mapStateToProps = state =&gt; {
  return {
    movies: state.movies,
    moviesToWatch: state.moviesToWatch,
    user: state.user
  }
}</code></pre>
    <p>
      Let’s pass this in as the first argument to the first
      <code>connect</code> invocation. Notice that <code>state</code> is being
      passed into this function. Under the hood, connect passes our entire state
      tree to <code>mapStateToProps</code>. That means that within that
      function, we have access to all our state via the
      <code>state</code> argument. But, the component only receives the pieces
      of state that we turn out of <code>mapStateToProps</code>.
    </p>
    <pre><code>export default connect(mapStateToProps, {})(MovieList)</code></pre>
    <p>
      Now, if you look at the props in the React tools, you will see that all
      three pieces of our state have been passed to our component through the
      <code>connect</code> function! As a side note, other props we’ve passed to
      this component the traditional way are still going to be available.
    </p>
    <p>
      <em
        >By the way, did you notice that we are using a function that takes in a
        component, extends its functionality, and returns a component?
        <code>connect</code> is a HOC!!!`</em
      >
    </p>
    <h2 id="challenge-2">Challenge</h2>
    <p>
      Create a new application. Add the <code>redux</code> and
      <code>react-redux</code> packages. Create a redux store with some test
      data (have fun with this part!). Build a component and connect that
      component to the store using <code>connect</code> and a
      <code>mapStateToProps</code> function. Render the connected data from your
      connected component.
    </p>
    <p>
      <a
        href="https://lambdaschool.instructure.com/courses/1218/pages/objective-3-use-the-connect-function-to-connect-react-components-to-the-redux-store?module_item_id=597498"
        >Source</a
      >
    </p>
    <h1
      id="objective-4---write-actions-and-action-creators-to-describe-state-changes-web43---3.2"
    >
      Objective 4 - write Actions and Action Creators to describe state changes:
      WEB43 - 3.2
    </h1>
    <blockquote>
      <p>
        In the world of Redux there’s a whole new set of programmer jargon. The
        first we’ll talk about here is actions.
      </p>
    </blockquote>
    <h2 id="overview-3">Overview</h2>
    <p>
      In the world of Redux there’s a whole new set of programmer jargon. The
      first we’ll talk about here is <code>actions</code>.
    </p>
    <h3 id="actions">Actions</h3>
    <p>
      Actions in Redux are packets of information that contain an action type
      and associated data.
    </p>
    <p>
      In code, an action is simply an object with up to two properties - a
      <code>type</code> property and an optional <code>payload</code> property.
      Each action MUST have a <code>type</code> property. The
      <code>type</code> property is a string that explains what interaction just
      happened. By convention, we use all caps and underscores for types - ie
      <code>'LOGIN_USER</code> or <code>TOGGLE_TODO</code>. The
      <code>payload</code> property is data that goes along with that
      interaction.
    </p>
    <p>
      Actions are “dispatched” to our reducer - aka, passed into the reducer
      function as an argument. When our reducer recieves an action, it will
      update the state according to the type and payload on the action.
    </p>
    <p>
      Let’s say we have a toggle handler function that switches a boolean field
      called <code>show</code>, which is set on our state in our Redux store. An
      action for such an event would look like this:
    </p>
    <pre><code>{ type: &quot;TOGGLE_SHOW&quot;, show: !state.show };</code></pre>
    <p>
      This allows us to keep things as simple as possible when responding to
      events and interactions!
    </p>
    <p>
      Importantly in Redux, reducers are the only place we can update our state.
      Actions tell our reducers “how” to update the state, and perhaps with what
      data it should be updated, but <strong>only</strong> a reducer can
      actually update the state. <em>More to come on reducers later.</em>.
    </p>
    <p>
      From what we’ve learned so far, we can start to see the flow of data in a
      React/Redux application:
    </p>
    <pre><code>Store sets the state -&gt;
Event or user interaction happens -&gt;
An action desctibing the event and possible changes is dispatched to reducer -&gt;
The reducer handles the action and replaces the store accordingly.</code></pre>
    <h3 id="action-creators">Action creators</h3>
    <p>
      Actions should not be confused with <code>action creators</code> (though
      admittedly, it’s very easy to confuse them). An action creator is a
      function that <em>creates</em> an action. Or in other words, an action
      creator is a function that returns an action object.
    </p>
    <p>
      Action creators are a middle step between events/interactions and the
      dispatch process. They make it possible to write reusable functions that
      can create actions on the fly, rather than us hard coding actions into our
      components. With action creators in mind, here is an updated look at our
      data flow:
    </p>
    <pre><code>Store sets the state -&gt;
Event or user interaction happens -&gt;
An action creator is called and dispatches an action -&gt;
Actions tell us about the changes from the event -&gt;
Reducers handle those actions and replace the store accordingly.</code></pre>
    <p>
      This flow is one of the reasons that Redux is so powerful. The two major
      principles here are <code>Functional Programming</code> and
      <code>Immutability</code>. Dispatched actions are the trigger for
      reducers, and reducers are pure functions that never produce any
      side-effects. Everything you do in Redux is functional.
    </p>
    <h3 id="action-types">Action types</h3>
    <p>
      The final term we want to cover here is <code>action types</code>. We’ve
      talked about, and even demonstrated the <code>type</code> property of an
      action. We want to change that up right now, ever-so-slightly… Instead of
      passing a string to <code>action.type</code> we create a variable with the
      name of the string, and assign it the string we would have passed to an
      action. Then we give <code>action.type</code> the variable as it’s value.
    </p>
    <p>
      We do this because we deal with strings like we deal with
      <code>types</code>. Strings are used in multiple places like you’ll see in
      reducers very soon, misspellings occur, and are very hard to debug. If we
      misspell our action type in our reducer, our state won’t be updated
      correctly, and we’ll be left wondering what went wrong.
    </p>
    <p>
      Instead, we’ll create an action type, and import it wherever we need it.
      That way, with linters IntelliSense in our code editor, we can spot errors
      a lot quicker. This is what action types looks like:
    </p>
    <pre><code>export const TOGGLE_SHOW = &#39;TOGGLE_SHOW&#39;;


{ type: TOGGLE_SHOW, payload: !state.show }</code></pre>
    <p>Now let’s try all of this in code!</p>
    <h2 id="follow-along-3">Follow Along</h2>
    <p>
      Let’s build our first action creator. We’ll assume that we have a Redux
      store connected to our app, and a component connected to the store. On the
      state object, we have a <code>title</code> property brought into the
      component via the <code>mapStateToProps</code> function. Our component has
      an input field and an “update title” button. When we type into the input
      and click the button, we want to update our state object with our new
      title. (You can start with
      <a href="https://codesandbox.io/s/rj862kxkkp"
        >this codesandbox (Links to an external site.)</a
      >)
    </p>
    <p>
      First, we need to create a new folder in the <code>src</code> folder
      called <code>actions</code>. Inside that folder, create an
      <code>actions.js</code> file. Inside that file, create a variable called
      <code>UPDATE_TITLE</code> with the value <code>'UPDATE_TITLE'</code>. The
      variable is an action type. Next, let’s create a function called
      <code>updateTitle</code> that takes in a new title. This will be our
      action creator, and it will simply return an action with the type
      <code>UPDATE_TITLE</code> and a payload of the new title we passed into
      it. Don’t forget to export both the action type and the action creator
      function. (Note that these will be <code>named exports</code>, so they
      will be imported with curly brace sytnax -
      <code>import { namedExport } from './place';</code>)
    </p>
    <pre><code>export const UPDATE_TITLE = &#39;UPDATE_TITLE&#39;;

export function updateTitle(newTitle) {
  return {
    type: UPDATE_TITLE,
    payload: newTitle
  }
}</code></pre>
    <p>
      See how easy that was? It sounded pretty scary up above, but in practice,
      this is all very concise and intuitive. Now we have an action creator that
      can dispatch our action to the reducer and send the reducer the new title.
      Let’s import our action creator into our component, and talk about how to
      use it there.
    </p>
    <p>
      When we use action creators in our connected components, we first import
      the action creator. Then, we pass the action creator into the
      <code>connect</code> function. Action creators are passed to the object
      that is the second argument in the first <code>connect</code> invocation.
    </p>
    <pre><code>export default connect(mapStateToProps, { actionCreator: actionCreator })(Component);</code></pre>
    <p>
      Then, just like the state pieces that we brought into our component via
      the <code>mapStateToProps</code> function, we have access to our action
      creator in props. This step is important because it is the
      <code>connect</code> function that works in the background to actually
      dispatch our actions to the reducer. We can’t just import an action
      creator and use it in our component. It must go through
      <code>connect</code> and be used from the props object.
    </p>
    <p>
      Let’s see how we would do this in the app we have been building. Go to the
      <code>Title</code> component, import <code>updateTitle</code>, and pass it
      into the <code>connect</code> function.
    </p>
    <pre><code>import React from &#39;react&#39;;
import { connect } from &#39;react-redux&#39;;

import { updateTitle } from &#39;../actions/actions&#39;;

...

export default connect(
  mapStateToProps,
  { updateTitle }
)(Title);</code></pre>
    <p>
      Now when the “Update title” button is pushed, invoke a function on the
      class that invokes <code>this.props.updateTitle</code> that gets
      <code>this.state.newTitleText</code> passed into it.
    </p>
    <pre><code>updateTitle = (e) =&gt; {
  e.preventDefault();
  this.props.updateTitle(this.state.newTitleText)
}

...

&lt;button onClick={this.updateTitle}&gt;Update title&lt;/button&gt;</code></pre>
    <p>
      Yes, names will be the same all over the place with this stuff. Just note
      that <code>props.updateTitle</code> is the action creator.
    </p>
    <p>
      To make sure it is working, let’s add a console.log in the action creator,
      and log out the newTitle that is passed into it. Since we don’t have a
      reducer to handle this action yet, we won’t see the state or title updated
      yet. So this is the best way we can make sure it’s working.
    </p>
    <pre><code>export function updateTitle(newTitle) {
  console.log(newTitle);
  return {
    type: UPDATE_TITLE,
    payload: newTitle
  }
}</code></pre>
    <p>
      Here’s what our
      <a href="https://codesandbox.io/s/w2n0o4qwmw"
        >codesandbox (Links to an external site.)</a
      >
      should look like now.
    </p>
    <h2 id="challenge-3">Challenge</h2>
    <p>
      In the application you created earlier, look at the state you are
      displaying. Find something easy, like a string or a number, to update.
      (Add a string to your state if you only have arrays or objects. This will
      keep things simple today while we learn this brand new state management
      flow). Build an action creator, pass it in to your component, and call
      that action creator (from props) after some interaction like a button
      click. Make sure you have a console.log in the action creator so you will
      know if it’s working.
    </p>
    <p>
      <a
        href="https://lambdaschool.instructure.com/courses/1218/pages/objective-4-write-actions-and-action-creators-to-describe-state-changes?module_item_id=597504"
        >Source</a
      >
    </p>
  </body>
</html>
