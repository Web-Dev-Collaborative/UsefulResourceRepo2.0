<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
<link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css" integrity="sha384-JcKb8q3iqJ61gNV9KGb8thSsNjpSL0n8PARn9HuZOnIxN0hoP+VmmDGMN5t9UJ0Z" crossorigin="anonymous">
<link rel="stylesheet" href="./prism.css">
<script async defer src="./prism.js"></script>
</head>
<body>;
<h1 id="introduction-to-authentication">Introduction to Authentication</h1>
<ul>
<li><em>“No query strings for passwords EVER”.</em></li>
</ul>
<p><strong>What is a hash?</strong> - A hash is a mathematical function that when given an input returns a string of fixed length. - To be effective it should: - Be Deterministic - Output a set length string - Be Nonreversible - Be infeasible to find hash - Yield a completely different output when inputs are similar</p>
<p><strong>What is a collision?</strong> - Hash functions can theoretically take every value in the known universe as an input, but return a string of fixed length. - As the output is of fixed length there is a maximum amount of different outputs. This gives rise to the concept of <strong>collisions</strong> - Collisions are where two input strings of a hash function produce the same hash result.</p>
<p><strong>Why are hash collisions bad?</strong> - File integrity checks will be compromised. - Exploitation of applications that uses password hashes. - Malicious files and viruses downloads.</p>
<p><strong>Attacking Hashed Passwords</strong> - One method would be building a table of hashes from the most common passwords and comparing each of them against the hashed value on the database. - Large versions of these tables generated by powerful processors are called <strong>Rainbow Tables</strong> - Disgruntled Employees…</p>
<p><strong>Defeating The Rainbow Table</strong> - We can increase the entropy of simple passwords by concatenating a <strong>secret</strong> before we hash the passwords. - A secret is a fixed string that is concatenated to the password before hashing. - The problem with the secret is that if it is leaked, an attacker can generate a new rainbow table based on the secret. - We can generate a random unique secret per user and store this with the user. This is called a <strong>salt</strong> - Having these salts in plain sight is okay because an attacker would need to generate a rainbow table per user which would make it practically infeasible to acquire every password on the database. - The tradeoff is that an attacker would feasibly be able to attack a single or few users.</p>
<p><strong>The Bcrypt Hash Salt Method</strong> 1. Generate Random salt 1. Hash password + salt 1. Prepend salt to hash 1. Save to database</p>
<p><strong>Using Bcrypt</strong></p>
<pre><code>const bcrypt = require(&#39;bcryptjs&#39;);</code></pre>
<pre><code>const hash = bcrypt.hashSync(user.password, &lt;Num Of Loops&gt;);</code></pre>
<pre><code>// Comparing login credentials with database

bcrypt.compareSync(credentials.password, user.password);

// =&gt; returns true or false</code></pre>
<p><strong>Hashing vs Encryption</strong> - Hashing = One-way function - Encryption = Bidirectional function (uses private keys to decrypt)</p>
<p><strong>Further Reading:</strong> - <em><a href="https://www.owasp.org/index.php/Security_by_Design_Principles">Security by Design</a></em></p>
</body></html>
