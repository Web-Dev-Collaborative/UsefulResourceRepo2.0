<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
<link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css" integrity="sha384-JcKb8q3iqJ61gNV9KGb8thSsNjpSL0n8PARn9HuZOnIxN0hoP+VmmDGMN5t9UJ0Z" crossorigin="anonymous">
<link rel="stylesheet" href="./prism.css">
<script async defer src="./prism.js"></script>
</head>
<body>;
<h1 id="hash-tables">Hash Tables</h1>
<h2 id="day-1">Day 1</h2>
<p>Task: Implement a basic hash table without collision resolution.</p>
<ol type="1">
<li><p>[X] Implement a <code>HashTable</code> class and <code>HashTableEntry</code> class.</p></li>
<li><p>[X] Implement a good hashing function (DJB2 &amp; FNV-1 (64-bit)).</p>
<p>You are allowed to Google for these hashing functions and implement from psuedocode.</p></li>
<li><p>[X] Implement the <code>hash_index()</code> that returns an index value fBor a key.</p></li>
<li><p>[X] Implement the <code>put()</code>, <code>get()</code>, and <code>delete()</code> methods.</p></li>
</ol>
<p>You can test this with:</p>
<pre><code>python test_hashtable_no_collisions.py</code></pre>
<p>The above test program is <em>unlikely</em> to have collisions, but it’s certainly possible for various hashing functions. With DJB2 (32 bit) and FNV-1 (64 bit) hashing functions, there are no collisions.</p>
<h2 id="day-2">Day 2</h2>
<p>Task: Implement linked-list chaining for collision resolution.</p>
<ol type="1">
<li><p>[X] Modify <code>put()</code>, <code>get()</code>, and <code>delete()</code> methods to handle collisions.</p></li>
<li><p>[X] There is no step 2.</p></li>
</ol>
<p>You can test this with:</p>
<pre><code>python test_hashtable.py</code></pre>
<p>Task: Implement load factor measurements and automatic hashtable size doubling.</p>
<ol type="1">
<li><p>[X] Compute and maintain load factor.</p></li>
<li><p>[X] When load factor increases above <code>0.7</code>, automatically rehash the table to double its previous size.</p></li>
<li><p>[X] Add the <code>resize()</code> method.</p></li>
</ol>
<p>You can test this with both of:</p>
<pre><code>python test_hashtable.py
python test_hashtable_resize.py</code></pre>
<ol start="4" type="1">
<li>[X] Stretch: When load factor decreases below <code>0.2</code>, automatically rehash the table to half its previous size, down to a minimum of 8 slots.</li>
</ol>
<h2 id="day-3-and-day-4">Day 3 and Day 4</h2>
<p>Work on the hashtable applications directory (in any order you wish–generally arranged from easier to harder, below).</p>
<p>For these, you can use either the built-in <code>dict</code> type, or the hashtable you built. (Some of these are easier with <code>dict</code> since it’s more full-featured.)</p>
<ol start="5" type="1">
<li>[X] <a href="applications/lookup_table/">Lookup Table</a></li>
<li>[X] <a href="applications/expensive_seq/">Expensive Sequence</a></li>
<li>[X] <a href="applications/word_count/">Word Count</a></li>
<li>[X] <a href="applications/no_dups/">No Duplicates</a></li>
<li>[X] <a href="applications/markov/">Markov Chains</a></li>
<li>[X] <a href="applications/histo/">Histogram</a></li>
<li>[X] <a href="applications/crack_caesar/">Cracking Caesar Ciphers</a></li>
<li>[X] <a href="applications/sumdiff/">Sum and Difference</a></li>
</ol>
</body></html>
