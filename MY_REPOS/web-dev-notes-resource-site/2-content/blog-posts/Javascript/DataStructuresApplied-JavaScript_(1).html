<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
<link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css" integrity="sha384-JcKb8q3iqJ61gNV9KGb8thSsNjpSL0n8PARn9HuZOnIxN0hoP+VmmDGMN5t9UJ0Z" crossorigin="anonymous">
<link rel="stylesheet" href="./prism.css">
<script async defer src="./prism.js"></script>
</head>
<body>;
<h1 id="data-structures-in-javascript">Data Structures in JavaScript</h1>
<blockquote>
<p>For Frontend Software Engineers</p>
</blockquote>
<h2 id="for-frontend-software-engineers">For Frontend Software Engineers</h2>
<p><a href="chrome-extension://cjedbglnccaioiolemnfhjncicchinao/@thonly?source=post_page-----1b9aed0ea17c--------------------------------"><img src="https://miro.medium.com/fit/c/96/96/1*GEKuz1L4KPVBovXQLXM6sA.jpeg" alt="Thon Ly" /></a></p>
<figure>
<img src="https://miro.medium.com/max/60/1*hj2M1t554I3w8SBorwlM2A.jpeg?q=20" alt="Image for post" /><figcaption>Image for post</figcaption>
</figure>
<figure>
<img src="https://miro.medium.com/max/2560/1*hj2M1t554I3w8SBorwlM2A.jpeg" alt="Image for post" /><figcaption>Image for post</figcaption>
</figure>
<p>As <em>business logic</em> moves from the back to the front more and more, expertise in <em>Frontend Engineering</em>
  becomes ever more crucial. As <strong>Frontend Engineers</strong>, we depend on view libraries like
  <strong>React</strong> to be productive. View libraries in turn depend on state libraries like <strong>Redux</strong>
  to manage the data. Together, React and Redux subscribe to the <em>reactive programming</em> paradigm in which UI
  updates <em>react</em> to data changes. Increasingly, backends act simply as API servers, providing endpoints only to
  retrieve and update the data. In effect, the backend just “forwards" the <em>database</em> to the frontend, expecting
  the Frontend Engineer to handle all the controller logic. The rising popularity of <em>microservices</em> and
  <strong>GraphQL</strong> attest to this growing trend.</p>
<p>Now, in addition to having aesthetic understanding of HTML and CSS, Frontend Engineers are expected to master
  JavaScript as well. As datastores on the client become “replicas" of databases on the server, intimate knowledge of
  idiomatic data structures becomes pivotal. In fact, an engineer’s level of experience can be inferred from his or her
  ability to distinguish <em>when</em> and <em>why</em> to use a particular data structure.</p>
<blockquote>
<p>Bad programmers worry about the code. Good programmers worry about data structures and their relationships.</p>
<p>— Linus Torvalds, Creator of Linux and Git</p>
</blockquote>
<p>At a high level, there are basically three types of data structures. <strong>Stacks</strong> and <strong>Queues</strong> are <em>array-like</em> structures that differ only in how items are inserted and removed. <strong>Linked Lists</strong>, <strong>Trees</strong>, and <strong>Graphs</strong> are structures with <em>nodes</em> that keep <em>references</em> to other nodes. <strong>Hash Tables</strong> depend on <em>hash functions</em> to save and locate data.</p>
<p>In terms of complexity, <code>Stacks</code> and <code>Queues</code> are the simplest and can be constructed from <code>Linked Lists</code>. <code>Trees</code> and <code>Graphs</code> are the most complex because they extend the concept of a linked list. <code>Hash Tables</code> need to utilize these data structures to perform reliably. In terms of efficiency, <strong>Linked Lists</strong> are most optimal for <em>recording</em> and <em>storing</em> of data, while <strong>Hash Tables</strong> are most performant for <em>searching</em> and <em>retrieving</em> of data.</p>
<p>To explain <em>why</em> and illustrate <em>when</em>, this article will conform to the order of these dependencies. Let’s begin!</p>
<p>Arguably the most important <code>Stack</code> in JavaScript is the <strong>call stack</strong> where we push in the <strong>scope</strong> of a <code>function</code> whenever we execute it. Programmatically, it’s just an <code>array</code> with two principled operations: <code>push</code> and <code>pop</code>. <strong>Push</strong> <em>adds</em> elements to the <em>top</em> of the array, while <strong>Pop</strong> <em>removes</em> them from the same location. In other words, <strong>Stacks</strong> follow the “Last In, First Out" protocol (LIFO).</p>
<p>Below is an example of a <code>Stack</code> in code. Notice that we can <em>reverse</em> the order of the stack: the bottom becomes the top and the top becomes the bottom. As such, we can use the array’s <code>unshift</code> and <code>shift</code> methods in place of <code>push</code> and <code>pop</code>, respectively.</p>
<p>As the number of items grows, <code>push</code>/<code>pop</code> becomes increasingly more performant than <code>unshift</code>/<code>shift</code> because every item needs to be reindexed in the latter but not the former.</p>
<p>JavaScript is an <strong>event-driven</strong> programming language which makes it possible to support <em>non-blocking</em> operations. Internally, the browser manages only <em>one thread</em> to run the entire JavaScript code, using the <strong>event queue</strong> to <em>enqueue</em> <code>listeners</code> and the <strong>event loop</strong> to <em>listen</em> for the registered <code>events</code>. To support asynchronicity in a single-threaded environment (to save CPU resources and enhance the web experience), <code>listener functions</code> <em>dequeue</em> and execute only when the <strong>call stack</strong> is empty. <code>Promises</code> depend on this <em>event-driven</em> <strong>architecture</strong> to allow a “synchronous-style" execution of asynchronous code that does not block other operations.</p>
<p>Programmatically, <code>Queues</code> are just arrays with two primary operations: <code>unshift</code> and <code>pop</code>. <strong>Unshift</strong> <em>enqueues</em> items to the <em>end</em> of the array, while <strong>Pop</strong> <em>dequeues</em> them from the <em>beginning</em> of the array. In other words, <strong>Queues</strong> follow the “First In, First Out" protocol (FIFO). If the direction is reversed, we can replace <code>unshift</code> and <code>pop</code> with <code>push</code> and <code>shift</code>, respectively.</p>
<p>An example of a <code>Queue</code> in code:</p>
<p>Like arrays, <code>Linked Lists</code> store data elements in <em>sequential</em> order. Instead of keeping indexes, linked lists hold <em>pointers</em> to other elements. The <em>first</em> <em>node</em> is called the <strong>head</strong> while the <em>last</em> <em>node</em> is called the <strong>tail</strong>. In a <strong>singly-linked list</strong>, each node has only one pointer to the <em>next</em> node. Here, the <em>head</em> is where we begin our walk down the rest of the list. In a <strong>doubly-linked list</strong>, a pointer to the <em>previous</em> node is also kept. Therefore, we can also start from the <em>tail</em> and walk “backwards" toward the head.</p>
<p>Linked lists have <strong><em>constant-time</em></strong> <em>insertions</em> and <em>deletions</em> because we can just change the pointers. To do the same operations in arrays requires <em>linear time</em> because subsequent items need to be shifted over. Also, linked lists can grow as long as there is space. However, even “dynamic" arrays that automatically resize could become unexpectedly expensive. Of course, there’s always a tradeoff. To lookup or edit an element in a linked list, we might have to walk the entire length which equates to linear time. With array indexes, however, such operations are trivial.</p>
<p>Like arrays, linked lists can operate as <em>stacks</em>. It’s as simple as having the head be the only place for insertion and removal. Linked lists can also operate as <em>queues</em>. This can be achieved with a doubly-linked list, where insertion occurs at the tail and removal occurs at the head, or vice versa. For large numbers of elements, this way of implementing queues is more performant than using arrays because <code>shift</code> and <code>unshift</code> operations at the beginning of arrays require linear time to re-index every subsequent element.</p>
<p>Linked lists are useful on both the client and server. On the client, state management libraries like <strong>Redux</strong> structure its middleware logic in a linked-list fashion. When <em>actions</em> are dispatched, they are piped from one middleware to the next until all is visited before reaching the <em>reducers</em>. On the server, web frameworks like <strong>Express</strong> also structure its middleware logic in a similar fashion. When a <em>request</em> is received, it is piped from one middleware to the next until a <em>response</em> is issued.</p>
<p>An example of a <code>Doubly-Linked List</code> in code:</p>
<p>A <code>Tree</code> is like a <em>linked list</em>, except it keeps references to <em>many</em> <strong>child nodes</strong> in a <em>hierarchical</em> structure. In other words, each node can have no more than one parent. The <strong>Document Object Model</strong> (DOM) is such a structure, with a root <code>html</code> node that branches into the <code>head</code> and <code>body</code> nodes, which further subdivide into all the familiar <em>html tags</em>. Under the hood, <em>prototypal inheritance</em> and <em>composition</em> with React components also produce tree structures. Of course, as an in-memory representation of the DOM, React’s <strong>Virtual DOM</strong> is also a tree structure.</p>
<p>The <strong>Binary Search Tree</strong> is special because each node can have no more than <em>two children</em>. The <strong>left child</strong> must have a value that is <em>smaller than</em> or equal to its parent, while the <strong>right child</strong> must have a <em>greater value</em>. Structured and balanced in this way, we can <em>search</em> for any value in <em>logarithmic</em> time because we can ignore one-half of the branching with each iteration. <em>Inserting</em> and <em>deleting</em> can also happen in logarithmic time. Moreover, the <em>smallest</em> and <em>largest</em> <em>value</em> can easily be found at the <em>leftmost</em> and <em>rightmost</em> <em>leaf</em>, respectively.</p>
<p>Traversal through the tree can happen in a <em>vertical</em> or <em>horizontal</em> procedure. In <strong>Depth-First Traversal</strong> (DFT) in the vertical direction, a recursive algorithm is more elegant than an iterative one. Nodes can be traversed in <em>pre-order</em>, <em>in-order</em>, or <em>post-order</em>. If we need to explore the roots before inspecting the leaves, we should choose <em>pre-order</em>. But, if we need to explore the leaves before the roots, we should choose <em>post-order</em>. As its name implies, <em>in-order</em> enables us to traverse the nodes in <em>sequential</em> order. This property makes Binary Search Trees optimal for <em>sorting</em>.</p>
<p>In <strong>Breadth-First Traversal</strong> (BFT) in the horizontal direction, an iterative approach is more elegant than a recursive one. This requires the use of a <code>queue</code> to track all the children nodes with each iteration. The memory needed for such a queue might not be trivial, however. If the shape of a tree is wider than deep, BFT is a better choice than DFT. Also, the path that BFT takes between any two nodes is the shortest one possible.</p>
<p>An example of a <code>Binary Search Tree</code> in code:</p>
<p>If a tree is free to have more than one parent, it becomes a <code>Graph</code>. <strong>Edges</strong> that connect nodes together in a graph can be <em>directed</em> or <em>undirected, weighted</em> or <em>unweighted</em>. Edges that have both direction and weight are analogous to <em>vectors</em>.</p>
<p>Multiple inheritances in the form of <em>Mixins</em> and data objects that have <em>many-to-many</em> relationships produce graph structures. A social network and the Internet itself are also graphs. The most complicated graph in nature is our human brain, which <strong>neural networks</strong> attempt to replicate to give machines <em>superintelligence</em>.</p>
<p>An example of a <code>Graph</code> in code:</p>
<p>TK</p>
<p>A <strong>Hash Table</strong> is a dictionary-like structure that pairs <em>keys</em> to <em>values</em>. The location in memory of each pair is determined by a <code>hash function</code>, which accepts a <em>key</em> and returns the <em>address</em> where the pair should be inserted and retrieved. Collisions can result if two or more keys convert to the same address. For robustness, <code>getters</code> and <code>setters</code> should anticipate these events to ensure that all data can be recovered and no data is overwritten. Usually, <code>linked lists</code> offer the simplest solution. Having very large tables also helps.</p>
<p>If we know our addresses will be in integer sequences, we can simply use <code>Arrays</code> to store our key-value pairs. For more complex address mappings, we can use <code>Maps</code> or <code>Objects</code>. Hash tables have insertion and lookup of <em>constant</em> time on average. Because of collisions and resizing, this negligible cost could grow to linear time. In practice, however, we can assume that hash functions are clever enough that collisions and resizing are rare and cheap. If keys represent addresses, and therefore no hashing is needed, a simple <code>object literal</code> can suffice. Of course, there’s always a tradeoff. The simple correspondence between keys and values, and the simple associativity between keys and addresses, sacrifice relationships <em>between</em> data. Thus, hash tables are suboptimal for <em>storing</em> data.</p>
<p>If a tradeoff decision favors retrieval over storage, no other data structure can match the speed of hash tables for <em>lookup</em>, <em>insertion</em>, and <em>deletion</em>. It’s no surprise, therefore, that it’s used <em>everywhere</em>. From the database, to the server, to the client, <em>hash tables</em>, and in particular, <em>hash functions</em>, are crucial to the performance and security of software applications. The speed of <strong>database</strong> <strong>queries</strong> relies heavily upon keeping tables of <em>indexes</em> that point to records in <em>sorted</em> order. This way, <em>binary searches</em> can be performed in <em>logarithmic</em> time, a huge performance win especially for <strong>Big Data</strong>.</p>
<p>On both the client and server, many popular libraries utilize <strong>memoization</strong> to maximize performance. By keeping a record of the <em>inputs</em> and <em>outputs</em> in a hash table, functions run only once for the same inputs. The popular <strong>Reselect</strong> library uses this caching strategy to optimize <code>mapStateToProps</code> functions in <strong>Redux</strong>-enabled applications. In fact, under the hood, the JavaScript engine also utilizes hash tables called <em>heaps</em> to store all the <code>variables</code> and <code>primitives</code> we create. They are accessed from <em>pointers</em> on the <em>call stack</em>.</p>
<p>The <strong>Internet</strong> itself also relies on <em>hashing algorithms</em> to function securely. The structure of the internet is such that any computer can communicate with any other computer through a <em>web</em> of interconnected devices. Whenever a device logs onto the internet, it also becomes a <em>router</em> through which data streams can travel. However, it’s a double-edged sword. A <em>decentralized</em> architecture means any device in the network can listen in and tamper with the data packages that it helps to relay. Hash functions such as MD5 and SHA256 play a critical role in preventing such <em>man-in-the-middle</em> attacks. E-commerce over HTTPS is safe only because these hashing functions are used.</p>
<p>Inspired by the Internet, <strong>blockchain</strong> technologies seek to <em>open source</em> the very structure of the web <em>at the protocol level</em>. By using hash functions to create <em>immutable</em> <em>fingerprints</em> for every <em>block</em> <em>of data</em>, essentially the entire database can exist <em>openly</em> on the web for anyone to see and contribute to. Structurally, blockchains are just singly-linked lists of binary trees of cryptographic hashes. The hashing is so cryptic that a database of financial transactions can be created and updated <em>out in the open</em> by anyone! The incredible implication is the awesome power to create <em>money</em> itself. What was once only possible for governments and central banks, now <em>anyone</em> can securely create his or her own <em>currency</em>! This is the key insight realized by the founder of <strong>Ethereum</strong> and the pseudonymous founder of <strong>Bitcoin</strong>.</p>
<p>As more and more databases move out into the open, the need for Frontend Engineers who can abstract away all the low-level cryptographic complexities will compound as well. In this future, the <em>main differentiator</em> will be the <strong>user experience</strong>.</p>
<p>An example of a <code>Hash Table</code> in code:</p>
<p><em>For algorithm exercises using these data structures and more, check out:</em> <a href="chrome-extension://cjedbglnccaioiolemnfhjncicchinao/siliconwat/algorithms-in-javascript-b0bed68f4038"><strong><em>Algorithms in JavaScript: 40 Problems, Solutions, and Explanations</em></strong></a></p>
<p>As logic moves increasingly from the server to the client, the <em>data layer</em> on the frontend becomes paramount. The proper management of this layer entails mastery of the data structures upon which logic rests. No one data structure is perfect for every situation because optimizing for one property always equates to losing another. Some structures are more efficient at storing data while some others are more performant for searching through them. Usually, one is sacrificed for the other. At one extreme, <strong>linked lists</strong> are optimal for storage and can be made into <strong>stacks</strong> and <strong>queues</strong> (<em>linear</em> time). At the other, no other structure can match the search speed of <strong>hash tables</strong> (<em>constant</em> time). <strong>Tree</strong> structures lie somewhere in the middle (<em>logarithmic</em> time), and only a <strong>graph</strong> can portray nature’s most complex structure: the human brain (<em>polynomial time</em>). Having the skillset to distinguish <em>when</em> and articulate <em>why</em> is a hallmark of a rockstar engineer.</p>
<p>Examples of these data structures can be found <em>everywhere</em>. From the database, to the server, to the client, and even the JavaScript engine itself, these data structures concretize what essentially are just <em>on</em> and <em>off</em> “switches" on silicon chips into lifelike “objects". Though only digital, the impact these objects have on society is tremendous. Your ability to read this article freely and securely attests to the awesome architecture of the internet and the structure of its data. Yet, this is only the beginning. Artificial intelligence and decentralized blockchains in the coming decades will redefine what it means to be human and the role of institutions that govern our lives. Existential insights and institutional disintermediation will be characteristics of an internet that has finally matured.</p>
<p>To help transition us towards this more equitable future, we at</p>
<p>channel networks of <em>artificial neurons</em> to imbue our</p>
<p>with the power to issue money on the blockchain, coupled with the capacity to empathize the human condition. From the <em>anonymous</em> <em>thanks</em> we give and receive by writing to</p>
<p>,</p>
<p>learns about our <em>kindnesses</em> and their <em>effects</em>, rewarding us in such a way that reduces the economic inequities between us, in a gradual and mysterious process that preserves our personal liberty and freedom. Perhaps the ultimate graph structure in nature is not the human brain, but the human ❤️, if only we can see the <em>heartstrings</em> that connect us all.</p>
<p><em>Interested in</em> <strong><em>blockchain</em></strong>_?_ <a href="chrome-extension://cjedbglnccaioiolemnfhjncicchinao/heartbankacademy/a-complete-mental-model-for-ethereum-dapp-development-5ce08598ed0a"><em>Learn Ethereum</em></a> <em>and come work for us!</em></p>
<p><a href="https://medium.com/siliconwat/data-structures-in-javascript-1b9aed0ea17c">Source</a></p>
</body></html>
