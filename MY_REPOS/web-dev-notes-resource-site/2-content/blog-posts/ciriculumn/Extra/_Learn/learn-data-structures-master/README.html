<h1 id="learn-data-structures">learn-data-structures</h1>
<p>Learn about data structures and algorithms, and the effects they can have on code performance</p>
<h2 id="why"><em>Why</em>?</h2>
<p>Data structures and algorithms play a massive role in any and every programming language. With a better understanding of both you can pick the ones that best suit your needs and massively speed up your applications.</p>
<p><strong>Better hardware is not a solution</strong></p>
<p>Better hardware can only do so much. No matter how powerful your hardware is, it is not going to make up for an inefficient algorithm.</p>
<p>The right choices in data structure and algorithm could be the difference between something being processed in seconds or hours.</p>
<h2 id="what"><em>What</em>?</h2>
<h3 id="data-structures">Data Structures</h3>
<blockquote>
<p>Data is a broad term that refers to all types of information down to the most basic numbers and strings.</p>
</blockquote>
<p><a href="https://en.wikipedia.org/wiki/Data_structure">Data structures</a>, refer to how data is organised.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode elixir"><code class="sourceCode elixir"><a class="sourceLine" id="cb1-1" title="1">hello <span class="op">=</span> <span class="st">&quot;hello&quot;</span> <span class="co"># data</span></a>
<a class="sourceLine" id="cb1-2" title="2">world <span class="op">=</span> <span class="st">&quot;world&quot;</span> <span class="co"># data</span></a>
<a class="sourceLine" id="cb1-3" title="3"></a>
<a class="sourceLine" id="cb1-4" title="4">[hello, world] <span class="co"># data structure</span></a></code></pre></div>
<h3 id="algorithms">Algorithms</h3>
<p>Simply put, an <a href="https://en.wikipedia.org/wiki/Algorithm">algorithm</a> is a set of steps for solving a problem. You would used an algorithm for making a sandwich for example:</p>
<pre><code>1 - Grab 2 slices of bread
2 - Butter each slice
3 - Put filling on top of one of the slices
4 - Put other slice on top of filling ðŸ¥ª</code></pre>
<p>In computing an algorithm is the same thing. Just a set of steps for a computer program to accomplish a task.</p>
<p>There are often a number of ways your could accomplish a task so learning to pick the right algorithm is key.</p>
<h2 id="how"><em>How</em>?</h2>
<p>Most examples of code in this README will be in elixir. If you would like to learn a little more about elixir, head over to <a href="https://github.com/dwyl/learn-elixir">learn-elixir</a>.</p>
<h2 id="data-structures-1">Data Structures</h2>
<p>As we mentioned earlier, data structures refer to how data is organised. This organisation is not just for organisationâ€™s sake however. The data structures you use could massively effect the speed at which your application runs. It could even be the difference between whether you app runs at all or errors because it cannot handle the load.</p>
<p>Learning about the different types of data structures and the pros/cons of each will allow you to pick the one that best suits the needs of your application.</p>
<h3 id="operations">Operations</h3>
<p>Operations are how we interact with data structures. Some of the common operations are as follows:</p>
<ul>
<li>Insert: To add a value to a data structure</li>
<li>Delete: To remove a value from a data structure</li>
<li>Read: Looking something up from a specific spot in a data structure</li>
<li>Search: Looking for a value in a data structure</li>
</ul>
<p>Different operations run at different speeds. However, speed is not measured in time as you expect. It is measured in the number of steps that the operation takes to complete.</p>
<p>The reason for this is because the time an operation will take can vary from machine to machine. It may take 5 seconds to search for a value on an older computer compared to 2 seconds on a newer one, despite the fact that they are using the same operation.</p>
<p>If the operation is measured in the number of steps that it takes though, this is a constant value that will not vary no matter the machine. If a operation takes 2 steps on â€˜machine aâ€™, it will take 2 steps on â€˜machine bâ€™. And an operation that take 2 steps will always be faster than an operation that takes 200.</p>
<p>Now letâ€™s take a look at these operations being applied to an array (the first data structure we are going to look at)</p>
<h3 id="array">Array</h3>
<p>An <a href="https://en.wikipedia.org/wiki/Array_data_structure">array</a> is just a list of data elements.</p>
<pre><code>array = [&quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;four&quot;, &quot;five&quot;]</code></pre>
<h4 id="reading">Reading</h4>
<blockquote>
<p>The following examples are not â€˜exactlyâ€™ how the computer stores arrays in memory. The computer actually stores all the elements of an array together in memory, with each cell of the computerâ€™s memory holding one elementâ€™s value. The computer records the memory address of where that array started and uses it to jump straight to that spot in memory. How the computer stores the information is not the key point here so we will not go into much detail here.</p>
</blockquote>
<p><strong>Reading from an array takes one step</strong>. Each cell in an array is given an index. The index always begins at 0 and increases by 1 with each element. The computer is able to â€˜jumpâ€™ to any index in an array and get the data from inside.</p>
<p>So for using the array above, say we want to get the element from the 2nd index. The computer knows that the first index is index 0 and that index 2 is exactly 2 over from index 0. With this the computer can jump right to the 2nd and then grab the data from that point.</p>
<h4 id="searching">Searching</h4>
<p>If we wanted to check if a value exists in this array then we would use the search operation. Say we wanted to check if the value <code>"six"</code> was in the array. We can just glance at the array and clearly see that it is not, but the computer does not have this skill. The computer needs to access every element individually and check if the value it getâ€™s back is <code>"six"</code>. If it finds a match it will stop and return <code>true</code> otherwise it will continue until there are no more elements, at which point it will return <code>false</code>.</p>
<p>Letâ€™s count the number of steps that searching our array for the value <code>"six"</code> would take. The computer starts by checking index 0 and sees that the value it contains is <code>"one"</code> so moves on to the next index. At index 1 it checks the value and sees that it is <code>"two"</code>. This is not what we are looking for so the computer again moves onâ€¦. (the computer repeats these steps until it gets to the end of the array).</p>
<p>In total <strong>the computer had to check 5 elements before it could be sure that the value was not there so this operation took 5 steps to complete</strong>. If the array had a million values then the operation <strong>could potentially take a million steps</strong> to complete. However, if the element we were searching for was the first element in the array, then the operation would only take 1 step. <strong>The number of steps is dependent on where or if the element is in the array.</strong></p>
<p>This type of search is known as a <strong>linear search</strong>. There are other, more complex types of search as well but this is just a basic search that will work with all array types.</p>
<h4 id="inserting-and-deleting">Inserting and deleting</h4>
<p>Inserting and deleting from an array work fairly similarly to one another so Iâ€™ll cover both here.</p>
<p>Say we want to insert a value into our array. Similar to how the number of steps in searching is dependent on where the value is in the array, inserting depends on where you want to insert the element into the array. If you want to insert an element onto the end of an array then this is considered the â€˜best case scenarioâ€™ as it only take the computer one step.</p>
<p>The number of steps increase when you want to insert an element anywhere else in the array. Say for example you want to insert the value<code>"ten"</code> into our array near the beginning at index 2. But index 2 already has a value, it has the value <code>"three"</code>. As we do not want to replace any of the values in our array, we only want to add to it, we first need to shift all the values over to make space.</p>
<p>This means that <code>"five"</code> would become index 5, <code>"four"</code> would become index 4 and <code>"three"</code> would become index 3. Each one of these is an individual step as the next index cannot be shifted until the former has been complete. Now index 2 is free and we can insert the new value <code>"ten"</code> in.</p>
<p>Our array looks like this nowâ€¦</p>
<pre><code>[&quot;one&quot;, &quot;two&quot;, &quot;ten&quot;, &quot;three&quot;, &quot;four&quot;, &quot;five&quot;]</code></pre>
<p>This insert would have taken 4 steps in total.</p>
<pre><code>step 1 - shifting value &quot;five&quot; from index 4 to index 5
step 2 - shifting value &quot;four&quot; from index 3 to index 4
step 3 - shifting value &quot;three&quot; from index 2 to index 3
step 4 - inserting value &quot;ten&quot; in index 2</code></pre>
<p>The worst case for inserting into an array would be inserting into the start of it as all elements would have to be shifted before the insert could take place. This would mean that in our array of 5 elements the number of steps to take would be 6. Put another way, if <code>N</code> is the number of elements, the number of steps in the worst case for inserting is <code>N + 1</code>.</p>
<p>Deleting is very similar to the above. The best case is to delete an element from the end of the array and this will only take 1 step.</p>
<p>If we want to delete the value at index 2 from our array (the value <code>"ten"</code>) then the following steps would be takenâ€¦</p>
<pre><code>step 1 - deleting value &quot;ten&quot; in index 2
step 2 - shifting value &quot;three&quot; from index 3 to index 2
step 3 - shifting value &quot;four&quot; from index 4 to index 3
step 4 - shifting value &quot;five&quot; from index 5 to index 4</code></pre>
<p>The worst case for deleting, just like inserting, is to delete the first element from the array.</p>
<h3 id="set-array-based-set">Set (array-based set)</h3>
<p>An array based set is very similar to an array but with one key difference, <strong>it never allows duplicate values to be inserted.</strong></p>
<p>For example, what have the following setâ€¦</p>
<pre><code>set = [1,2,3]</code></pre>
<p>If we tried to add <code>1</code> to the set the computer would not let it happen as the set already contains the value.</p>
<p>Sets come in handy when you need to make sure that you have no duplicate data.</p>
<p>The operations that we used on our array all work in the same way on our set, with the exception of insert.</p>
<p>When we call insert on our array based set it does work similarly to our example above but, before it can insert, it first needs to check every cell to make sure the value we want to insert is not already in the set.</p>
<p>Letâ€™s take our currently defined set and try to insert the value <code>4</code> onto the end</p>
<pre><code>step 1 - check the value at index 0
step 2 - check the value at index 1
step 3 - check the value at index 2
step 4 - insert value 4 onto the end of set</code></pre>
<p>In the above example, we inserted onto the end of our set and it took 4 steps. Like inserting onto the end of an array, this is the best case scenario. Unlike the array, this took 4 steps compared to 1.</p>
<p>This means that if we had a set containing 1,000,000 items and we wanted to insert onto the end of that set it would take 1,000,000 steps checking the values in the indexes and then 1 step inserting. Number of steps is <code>N + 1</code>.</p>
<p>Remember, this is the best case scenario. The worst case scenario is if want to insert into the first element of our set. If we so this, it has to first check every index, then shift every index over by one (like inserting into the array did).</p>
<p>Letâ€™s insert <code>4</code> into the start of our set this timeâ€¦</p>
<pre><code>step 1 - check the value at index 0
step 2 - check the value at index 1
step 3 - check the value at index 2
step 4 - shift the value 3 to index 3
step 5 - shift the value 2 to index 2
step 6 - shift the value 1 to index 1
step 7 - insert value 4 into index 0</code></pre>
<p>This took 7 steps to complete. The way we could express this â€˜worst case scenarioâ€™ is <code>2N + 1</code>.</p>
<p>As you can see this is almost exactly double the number of steps needed to insert into an array. That doesnâ€™t mean that sets are a bad data structure however. If you need to make sure there is no duplicate data then this could be the right fit for you. If not, you may be better off with an array.</p>
<h3 id="ordered-array">Ordered Array</h3>
<p>An ordered array is again very similar to an array. The difference here, as the name suggests, is that this array has to be ordered.</p>
<p>Lets take the following arrayâ€¦</p>
<pre><code>[1,2,4,5]</code></pre>
<p>and try to insert the value <code>3</code>.</p>
<p>Inserting works in a similar way to the set insert. First the computer would have to go to index 0 and compare the value inside against the one we want to insert. If the value we want to insert is greater than what is inside index 0, then we move on. It repeats the steps until it comes across a value that is greater than the value we want to insert. At this point it then shifts all the values up an index and inserts the value.</p>
<p>In our case <code>3</code> would be inserted into index 2.</p>
<p>Search also works in a similar way to previous examples but with a key difference. With an ordered array, a search can stop early if we know a value could not possibly be contained in the array.</p>
<p>For example take the following array</p>
<pre><code>[1, 10, 37, 85, 96]</code></pre>
<p>Now we tell computer to search this for the value <code>26</code>. As we mentioned, the computer will need to check each cell, one at a time, in order, so it sounds pretty similar to the previous searches. The difference here is that when the computer comes across a cell that has a larger value than the one we are searching for, it can immediately stop looking as it knows it can not exist past that point.</p>
<pre><code>step 1 - check the value at index 0
step 2 - check the value at index 1
step 3 - check the value at index 2</code></pre>
<p>Only 3 steps needed. Once the computer gets to <code>index 2</code> and sees the value <code>37</code> it knows that is larger than the <code>26</code> we are looking for and can stop searching at that point.</p>
<p>Of course this wonâ€™t always be the case. If you were looking for 96, or greater, the search would still have to check every cell.</p>
<p>However this assumes that our search always starts at the beginning of an array and works its way through looking for the element in question. This is not true. A linear search is just one of many algorithms that can be used for searching arrays.</p>
<h2 id="algorithms-1">Algorithms</h2>
<p>An algorithm, as we mentioned earlier, is a set of steps for solving a problem.</p>
<p>There are many different algorithms, and there are often multiple algorithms that can be used to achieve the same end results. How they work will be different however.</p>
<p>Imagine you are travelling home and your travel options are, a combination of public transport and walking, or riding a bike. Both will have the same result of getting you home but one may be faster, safer, more convenient etc. For example, if your journey home was 300 miles long and there was a super fast train that took you within a 2 minute walk of your front door, this may be a better option than riding your bike home (unless you like that kind of thing). But this doesnâ€™t mean that public transport is always the way to go. Letâ€™s say now your journey home is only 2 miles and there is no direct transport option. In this situation it may be better for you to ride your bike.</p>
<p>The point of the above is to show that although both have the same result, depending on the situation, each â€˜algorithmâ€™ has its purpose.</p>
<p>Picking the one that suites your needs is important as it can greatly effect the performance of an application.</p>
<p>We have already seen how to perform a linear search on an array so letâ€™s check out a new type of search. Binary.</p>
<p>Binary search works by checking the middle element of a list, checking if it contains the value we are after, and depending on the value in that cell, knows if is should check the first or second half of the array. This means that after just one step, binary search has already found that it no longer needs to search half of the elements in the list (because of the way it works binary search can only be used on ordered arrays).</p>
<p>Letâ€™s look at an example array of 1 to 10.</p>
<pre><code>[1, 2, 3, 4, 5, 6, 7, 8, 9]</code></pre>
<p>And search for the value <code>7</code>.</p>
<p>If we were to use linear search the computer would check each cell, starting at <code>index 0</code> and working its way up the indexes until it finds our value. We can see that this would take <code>7</code> steps.</p>
<p>Letâ€™s see how binary search will effect this.</p>
<p>First the computer jumps to the middle of the array and checks the value there. That value is <code>5</code>. As we are searching for the number <code>7</code>, and as this is an ordered array, the computer knows that everything â€˜to the leftâ€™ of index 4 is also lower in value than 7. This means that is can remove these from the list of possible indexes left to check.</p>
<p>Now we are left with the values 6 to 9 to check. The computer will again pick the middle index and check to see if it contains our number. In our case there is no exact middle. Could be index 6 or 7 (values 7 or 8) but weâ€™ll say in this case the computer picks the lower of the two middle choices and goes with index 6.</p>
<p>Binary search just found our number in 2 steps!!!!!</p>
<pre><code>step 1 - check the value at index 4
  value is 5 so computer discards it and everything to the left away
  left with indexes of 5,6,7,8
step 2 - check the value at index 6
  value returned is 7</code></pre>
<p>Letâ€™s do another example where we have to look for <code>1,000,000</code> from an array of numbers ranging from 1 to 1,000,000. Remember, this is a worst case scenario.</p>
<p>As mentioned in the searching section above, the linear search would take all <code>1,000,000</code> steps to complete this. Letâ€™s compare this to the binary search</p>
<p>Binary steps</p>
<pre><code>  step 1 - check the value at 500,000
    value is less than we are looking for so discard it and everything less than
    it. (Just cleared HALF A MILLION STEPS IN ONE GO!!!!)
  step 2 - check the value at 750,000
    value is less than we are looking for so discard it and everything less than
    it.
  step 3 - check the value at 875,000 - too low, discard all to left
  step 4 - check the value at 937,500 - too low, discard all to left
  step 5 - check the value at 968,750 - you get the idea...
  step 6 - check the value at 968,750
  step 7 - check the value at 984,375
  step 8 - check the value at 992,187
  step 9 - check the value at 996,093
  step 10 - check the value at 998,046
  step 11 - check the value at 999,023
  step 12 - check the value at 999,511
  step 13 - check the value at 999,755 - getting close
  step 14 - check the value at 999,877
  step 15 - check the value at 999,938
  step 16 - check the value at 999,969
  step 17 - check the value at 999,984
  step 18 - check the value at 999,992
  step 19 - check the value at 999,996 - nearly there
  step 20 - check the value at 999,998
  step 21 - check the value at 999,999
  step 22 - check the value at 1,000,000 - WE MADE IT</code></pre>
<p>This might seem like a lot of text/steps but just think about what this search algorithm just managed to do. It took a worst case scenario of searching an array of <code>1,000,000</code> values for its <code>1,000,000</code>th value and fount it in 22 steps.</p>
<p>This means the maximum number of steps searching an ordered array of a million values with binary search is <code>22</code>. Quite the improvement over a million Iâ€™m sure youâ€™ll agree.</p>
<p>Check out <a href="https://www.youtube.com/watch?v=EXtkCmRXfMo">this youtube video</a> to learn more about binary and linear search.</p>
