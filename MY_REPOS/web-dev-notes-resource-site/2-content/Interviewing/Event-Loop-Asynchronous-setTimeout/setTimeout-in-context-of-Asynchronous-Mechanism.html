<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
<link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css" integrity="sha384-JcKb8q3iqJ61gNV9KGb8thSsNjpSL0n8PARn9HuZOnIxN0hoP+VmmDGMN5t9UJ0Z" crossorigin="anonymous">
<link rel="stylesheet" href="./prism.css">
<script async defer src="./prism.js"></script>
</head>
<body>;
<p>One of Javascript’s strength is the way it handles asynchronous (async) code. Instead of getting blocked, the thread is pushed in an event queue which gets fired after the execution of all the other codes. This means that you can let your code do several things at the same time without stopping or locking your main thread.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb1-1" title="1"><span class="va">Console</span>.<span class="at">log</span>( “a” )<span class="op">;</span></a>
<a class="sourceLine" id="cb1-2" title="2"><span class="at">setTimeout</span>(<span class="kw">function</span> () <span class="op">{</span></a>
<a class="sourceLine" id="cb1-3" title="3"><span class="va">Console</span>.<span class="at">log</span>( “c”)</a>
<a class="sourceLine" id="cb1-4" title="4"><span class="op">},</span> <span class="dv">500</span> )<span class="op">;</span></a>
<a class="sourceLine" id="cb1-5" title="5"><span class="at">setTimeout</span>(<span class="kw">function</span> () <span class="op">{</span></a>
<a class="sourceLine" id="cb1-6" title="6"><span class="va">Console</span>.<span class="at">log</span>( “d” )</a>
<a class="sourceLine" id="cb1-7" title="7"><span class="op">},</span>  <span class="dv">500</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb1-8" title="8"><span class="at">setTimeout</span>(<span class="kw">function</span> () <span class="op">{</span></a>
<a class="sourceLine" id="cb1-9" title="9"><span class="va">Console</span>.<span class="at">log</span>( “e” )</a>
<a class="sourceLine" id="cb1-10" title="10"><span class="op">},</span>  <span class="dv">500</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb1-11" title="11"><span class="va">Console</span>.<span class="at">log</span>( “b” )<span class="op">;</span></a></code></pre></div>
<p>The code above will result with the console displaying “a” and “b” first, then after 500 milliseconds, “c”, “d” and “e” will be displayed.</p>
<p>Note that a timeout will only be executed after all the code in a block has finished executing. If a long-running function is set before the timeout then the function will have to finish executing first before the setTimeout function gets executed.</p>
<h4 id="basically-async-functions-like-settimeout-and-setinterval-are-pushed-into-a-special-queue-known-as-the-event-loop.">Basically, async functions like setTimeout and setInterval are pushed into a special queue known as the “event loop”.</h4>
<h2 id="the-event-loop---its-a-first-in-first-out-task-queue-or-fifo-queue.">The Event Loop - Its a first-in-first-out task queue, or FIFO Queue.</h2>
<p>The event loop is a special queue for callback functions. When an async code is executed, a callback is then pushed into the queue. The Javascript engine will only execute the event loop if the code after the async function has finished executing. This is because, Javascript is single threaded.</p>
<p><strong>The event loop is a first-in-first-out type of queue – callbacks are processed in order they were added to the queue.</strong></p>
<h2 id="the-call-stack---its-a-lifo-data-structure-.">The Call Stack - Its a LIFO data structure .</h2>
<p>The event loop (Which on the other hand is FIFO) continuously checks the call stack to see if there’s any function that needs to run.</p>
<p>While doing so, it adds any function call it finds to the call stack and executes each one in order.</p>
<p>JavaScript has a single call stack in which it keeps track of what function we’re currently executing and what function is to be executed after that. But first — what’s a stack? A stack is an array-like data structure but with some limitations — you can only add items to the back and only remove the last item. Another example is a pile of plates — you put them on top of each other and at any time you can only remove the top one.</p>
<p>When you’re about to execute a function it is added on the call stack. Then if that function calls another function — the other function will be on top of the first one in the call stack. When you get an error in the console you get a long message that shows you the path of execution — this is what the stack looked in that exact moment. But what if we make a request or put a timeout on something? In theory that should freeze the entire browser until it is executed so the call stack can continue? In practice however, you know that this doesn’t happen — because of the Event Table and Event Queue.</p>
<h4 id="further-reading">Further Reading</h4>
<p><a href="https://www.hiddenwebgenius.com/guides/understanding-javascripts-asynchronous-code/">https://www.hiddenwebgenius.com/guides/understanding-javascripts-asynchronous-code/</a></p>
<p><a href="https://hackernoon.com/understanding-js-the-event-loop-959beae3ac40">https://hackernoon.com/understanding-js-the-event-loop-959beae3ac40</a></p>
</body></html>
