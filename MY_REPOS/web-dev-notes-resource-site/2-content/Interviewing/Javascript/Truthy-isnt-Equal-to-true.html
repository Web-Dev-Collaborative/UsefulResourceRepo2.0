<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
<link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css" integrity="sha384-JcKb8q3iqJ61gNV9KGb8thSsNjpSL0n8PARn9HuZOnIxN0hoP+VmmDGMN5t9UJ0Z" crossorigin="anonymous">
<link rel="stylesheet" href="./prism.css">
<script async defer src="./prism.js"></script>
</head>
<body>;
<h2 id="truthy-isnt-equal-to-true">Truthy isn’t Equal to true</h2>
<h3 id="question-as-is-true-true-should-also-be-true.-right">Question: As [] is true, []==true should also be true. right?</h3>
<h3 id="answer">Answer:</h3>
<p>You are right about first part, [], empty array is an object and object is always truthy. Hence, if you use <code>if([]){console.log('its true')}</code> you will see the log.</p>
<p>However, special case about == (double equal) is that it will do some implicit coercion.</p>
<p>Since left and right side of the equality are two different types, JavaScript can’t compare them directly . Hence, under the hood, JavaScript will convert them to compare. first right side of the equality will be cooereced to a number and number of true would be 1.</p>
<p>After that, JavaScript implementation will try to convert [] by usingtoPrimitive (of JavaScript implementation). since [].valueOf is not primitive will use toString and will get ""</p>
<p>Now you are comparing "" == 1 and still left and right is not same type. Hence left side will be converted again to a number and empty string will be 0.</p>
<p>Finally, they are of same type, you are comparing 0 === 1 which will be false.</p>
<p>ref: <a href="https://javascriptweblog.wordpress.com/2011/02/07/truth-equality-and-javascript/">truth and eqality in JS</a>, ref: <a href="http://www.sitepoint.com/javascript-truthy-falsy/">truthy and falsy</a></p>
</body></html>
