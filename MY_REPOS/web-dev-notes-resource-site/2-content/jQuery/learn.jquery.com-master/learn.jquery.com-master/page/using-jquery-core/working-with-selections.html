<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css"
        integrity="sha384-JcKb8q3iqJ61gNV9KGb8thSsNjpSL0n8PARn9HuZOnIxN0hoP+VmmDGMN5t9UJ0Z" crossorigin="anonymous">
    <link rel="stylesheet" href="./prism.css">
    <script async defer src="./prism.js"></script>
</head>

<body>;
    <!DOCTYPE html>
    <html lang="en">

    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Document</title>
        <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css"
            integrity="sha384-JcKb8q3iqJ61gNV9KGb8thSsNjpSL0n8PARn9HuZOnIxN0hoP+VmmDGMN5t9UJ0Z" crossorigin="anonymous">
        <link rel="stylesheet" href="./prism.css">
        <script async defer src="./prism.js"></script>
    </head>

    <body>;
        <script>
            {
                "title": "Working with Selections",
                "level": "beginner"
            }
        </script>
        <h3 id="getters-setters">Getters &amp; Setters</h3>
        <p>jQuery “overloads” its methods, so the method used to set a value generally has the same name as the method
            used to get a value. When a method is used to set a value, it’s called a setter. When a method is used to
            get (or read) a value, it’s called a getter. Setters affect all elements in a selection. Getters get the
            requested value only for the first element in the selection.</p>
        <pre><code>// The .html() method used as a setter:
$( &quot;h1&quot; ).html( &quot;hello world&quot; );</code></pre>
        <pre><code>// The .html() method used as a getter:
$( &quot;h1&quot; ).html();</code></pre>
        <p>Setters return a jQuery object, allowing you to continue calling jQuery methods on your selection. Getters
            return whatever they were asked to get, so you can’t continue to call jQuery methods on the value returned
            by the getter.</p>
        <pre><code>// Attempting to call a jQuery method after calling a getter.
// This will NOT work:
$( &quot;h1&quot; ).html().addClass( &quot;test&quot; );</code></pre>
        <h3 id="chaining">Chaining</h3>
        <p>If you call a method on a selection and that method returns a jQuery object, you can continue to call jQuery
            methods on the object without pausing for a semicolon. This practice is referred to as “chaining”:</p>
        <pre><code>$( &quot;#content&quot; ).find( &quot;h3&quot; ).eq( 2 ).html( &quot;new text for the third h3!&quot; );</code></pre>
        <p>It may help code readability to break the chain over several lines:</p>
        <pre><code>$( &quot;#content&quot; )
    .find( &quot;h3&quot; )
    .eq( 2 )
    .html( &quot;new text for the third h3!&quot; );</code></pre>
        <p>jQuery also provides the <code>.end()</code> method to get back to the original selection should you change
            the selection in the middle of a chain:</p>
        <pre><code>$( &quot;#content&quot; )
    .find( &quot;h3&quot; )
    .eq( 2 )
        .html( &quot;new text for the third h3!&quot; )
        .end() // Restores the selection to all h3s in #content
    .eq( 0 )
        .html( &quot;new text for the first h3!&quot; );</code></pre>
        <p>Chaining is extraordinarily powerful, and it’s a feature that many libraries have adapted since it was made
            popular by jQuery. However, it must be used with care – extensive chaining can make code extremely difficult
            to modify or debug. There is no hard-and-fast rule to how long a chain should be – just know that it’s easy
            to get carried away.</p>
    </body>

    </html>
</body>

</html>
