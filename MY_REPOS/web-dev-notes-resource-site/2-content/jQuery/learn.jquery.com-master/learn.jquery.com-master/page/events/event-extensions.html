<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
<link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css" integrity="sha384-JcKb8q3iqJ61gNV9KGb8thSsNjpSL0n8PARn9HuZOnIxN0hoP+VmmDGMN5t9UJ0Z" crossorigin="anonymous">
<link rel="stylesheet" href="./prism.css">
<script async defer src="./prism.js"></script>
</head>
<body>;
<script>{
    "title": "jQuery Event Extensions",
    "level": "advanced"
}</script>
<p>jQuery offers several ways to extend its event system to provide custom functionality when events are attached to elements. Internally in jQuery, these extensions are primarily used to ensure that standard events such as <code>submit</code> and <code>change</code> behave consistently across browsers. However, they can also be used to define new events with custom behavior.</p>
<p>This document covers the extensions available starting with jQuery 1.7; a sparsely documented subset of this functionality has been available since jQuery 1.3 but the differences in functionality are extensive. For an overview of special events in earlier versions, see <a href="http://benalman.com/news/2010/03/jquery-special-events/">Ben Alman’s jQuery Special Events</a> article.</p>
<div class="warning">
<strong>Note:</strong> jQuery event extensions are an advanced feature; they require deeper knowledge of both browser behavior and jQuery internals than most of the API. Most users of jQuery will not need to use event extensions, and those who do should use them with care. For example, on a large project with third-party plugins, changing the behavior of standard events such as <code>click</code> or <code>mouseover</code> can cause serious compatibility issues.
</div>
<h3 id="events-overview-and-general-advice">Events overview and general advice</h3>
<p>When writing an event extension, it is essential to understand the flow of events through jQuery’s internal event system. For a description of the event system from the API level, including a discussion of event delegation, see the <a href="http://api.jquery.com/on/"><code>.on()</code></a> method.</p>
<p>To simplify event management, jQuery only attaches a single event handler per element per event type (using <code>addEventListener</code> on W3C-compliant browsers or <code>attachEvent</code> on older IE) and then dispatches to event handlers that are attached via jQuery’s APIs. For example, if three “click” event handlers are attached to an element, jQuery attaches its own handler when the first handler is attached and adds the user’s event handler to a list to be executed when the event occurs. For subsequent event handlers, jQuery only adds them to its own internal list since it has already called the browser to attach its solitary handler. Conversely, jQuery removes its own event handler from the browser when the final event of a particular type is removed from the element.</p>
<p>An event can be a <em>native</em> event defined by the W3C and fired by the browser in response to something such as a user clicking a mouse button or pressing a key. It can also be a <em>custom</em> event, triggered only by code via jQuery’s <code>.trigger()</code> or <code>.triggerHandler()</code> methods. Code can also trigger native browser events, which is convenient for simulating user actions.</p>
<p>In general, jQuery does not have intrinsic knowledge of whether an event name may be fired by a browser. So by default, jQuery always attaches an event to the browser when an API call is made to add an event handler for that event. If that event type is never generated by the browser, the only way the handler will be called is if JavaScript code triggers the event. Although there is generally no harm in attaching an unused event name to the browser, the default behavior can be overridden using the special event <code>setup</code> hook as described below.</p>
<p>Whenever elements are removed from a document via jQuery, the event system tries to ensure that events and related data are removed from the elements to prevent memory leaks. (Older versions of Internet Explorer are notorious for leaking memory in these situations if not managed carefully.) If an event extension attaches events or creates new objects, it should detach those objects or clear the data when the event is removed by defining <code>remove</code> and <code>teardown</code> hooks.</p>
<p>jQuery event extension developers should avoid using event names that have special meaning in a DOM setting. Event names such as “click”, “change”, or “load” have specific semantics defined by the W3C, so using them as custom events can cause unexpected behavior. Generally, jQuery event extensions should <em>only</em> be used for W3C-defined event names when the extension is normalizing behavior across browsers. A common convention to avoid collisions for custom events is to embed a colon or dash in the event type name, since no W3C events use those characters.</p>
<p>Although jQuery’s event system is oriented towards delivering DOM events to DOM elements, jQuery methods can be used to attach and trigger events on plain objects. For example, it can be used as a simple publish/subscribe mechanism. Developers of event extensions should attempt to avoid unwanted behavior if their extensions are used in a mixed scenario with DOM and plain objects. The canonical way that jQuery detects a DOM element is to check for <code>elem.nodeType === 1</code> on the object.</p>
<h3 id="jquery.event.props-array">jQuery.event.props: Array</h3>
<p>jQuery defines an <a href="http://api.jquery.com/jQuery.Event/">Event object</a> that represents a cross-browser subset of the information available when an event occurs. The <code>jQuery.event.props</code> property is an array of string names for properties that are always copied when jQuery processes a <em>native</em> browser event. (Events fired in code by <code>.trigger()</code> do not use this list, since the code can construct a <code>jQuery.Event</code> object with the needed values and trigger using that object.)</p>
<p>To add a property name to this list, use <code>jQuery.event.props.push( "newPropertyName" )</code>. However, be aware that every event processed by jQuery will now attempt to copy this property name from the native browser event to jQuery’s constructed event. If the property does not exist for that event type, it will get an undefined value. Adding many properties to this list can significantly reduce event delivery performance, so for infrequently-needed properties it is more efficient to use the value directly from <code>event.originalEvent</code> instead. If properties must be copied, you are strongly advised to use <code>jQuery.event.fixHooks</code> as of version 1.7.</p>
<h3 id="jquery.event.fixhooks-object">jQuery.event.fixHooks: Object</h3>
<p>The <code>fixHooks</code> interface provides a per-event-type way to extend or normalize the event object that jQuery creates when it processes a <em>native</em> browser event. A <code>fixHooks</code> entry is an object that has two properties, each being optional:</p>
<p><code>props</code>: Array: Strings representing properties that should be copied from the browser’s event object to the jQuery event object. If omitted, no additional properties are copied beyond the standard ones that jQuery copies and normalizes (e.g. <code>event.target</code> and <code>event.relatedTarget</code>).</p>
<p><code>filter</code>: Function( event, originalEvent ): jQuery calls this function after it constructs the <code>jQuery.Event</code> object, copies standard properties from <code>jQuery.event.props</code>, and copies the <code>fixHooks</code>-specific props (if any) specified above. The function can create new properties on the event object or modify existing ones. The second argument is the browser’s native event object, which is also available in <code>event.originalEvent</code>.</p>
<p>Note that for all events, the browser’s native event object is available in <code>event.originalEvent</code>; if the jQuery event handler examines the properties there instead of jQuery’s normalized <code>event</code> object, there is no need to create a <code>fixHooks</code> entry to copy or modify the properties.</p>
<p>For example, to set a hook for the “drop” event that copies the <code>dataTransfer</code> property, assign an object to <code>jQuery.event.fixHooks.drop</code>:</p>
<pre><code>jQuery.event.fixHooks.drop = {
    props: [ &quot;dataTransfer&quot; ]
};</code></pre>
<p>Since <code>fixHooks</code> is an advanced feature and rarely used externally, jQuery does not include code or interfaces to deal with conflict resolution. If there is a chance that some other code may be assigning <code>fixHooks</code> to the same events, the code should check for an existing hook and take appropriate measures. A simple solution might look like this:</p>
<pre><code>if ( jQuery.event.fixHooks.drop ) {
    throw new Error( &quot;Someone else took the jQuery.event.fixHooks.drop hook!&quot; );
}

jQuery.event.fixHooks.drop = {
    props: [ &quot;dataTransfer&quot; ]
};</code></pre>
<p>When there are known cases of different plugins wanting to attach to the drop hook, this solution might be more appropriate:</p>
<pre><code>var existingHook = jQuery.event.fixHooks.drop;

if ( !existingHook ) {
    jQuery.event.fixHooks.drop = {
        props: [ &quot;dataTransfer&quot; ]
    };
} else {
    if ( existingHook.props ) {
        existingHook.props.push( &quot;dataTransfer&quot; );
    } else {
        existingHook.props = [ &quot;dataTransfer&quot; ];
    }
}</code></pre>
<h3 id="special-event-hooks">Special event hooks</h3>
<p>The jQuery special event hooks are a set of per-event-name functions and properties that allow code to control the behavior of event processing within jQuery. The mechanism is similar to <code>fixHooks</code> in that the special event information is stored in <code>jQuery.event.special.NAME</code>, where <code>NAME</code> is the name of the special event. Event names are case sensitive.</p>
<p>As with <code>fixHooks</code>, the special event hooks design assumes it will be very rare that two unrelated pieces of code want to process the same event name. Special event authors who need to modify events with existing hooks will need to take precautions to avoid introducing unwanted side-effects by clobbering those hooks.</p>
<h4 id="nobubble-boolean">noBubble: Boolean</h4>
<p>Indicates whether this event type should be bubbled when the <code>.trigger()</code> method is called; by default it is <code>false</code>, meaning that a triggered event will bubble to the element’s parents up to the document (if attached to a document) and then to the window. Note that defining <code>noBubble</code> on an event will effectively prevent that event from being used for delegated events with <code>.trigger()</code>.</p>
<h4 id="bindtype-string-delegatetype-string">bindType: String, delegateType: String</h4>
<p>When defined, these string properties specify that a special event should be handled like another event type until the event is delivered. The <code>bindType</code> is used if the event is attached directly, and the <code>delegateType</code> is used for delegated events. These types are generally DOM event types, and <em>should not</em> be a special event themselves.</p>
<p>The behavior of these properties is easiest to see with an example. Assume a special event defined as follows:</p>
<pre><code>jQuery.event.special.pushy = {
    bindType: &quot;click&quot;,
    delegateType: &quot;click&quot;
};</code></pre>
<p>When these properties are defined, the following behavior occurs in the jQuery event system:</p>
<ul>
<li>Event handlers for the “pushy” event are actually attached to “click” — both directly bound and delegated events.</li>
<li>Special event hooks for “click” are called if they exist, <em>except</em> the <code>handle</code> hook for “pushy” is called when an event is delivered if one exists.</li>
<li>Event handlers for “pushy” must be removed using the “pushy” event name, and are unaffected if “click” events are removed from the same elements.</li>
</ul>
<p>So given the special event above, this code shows that a pushy isn’t removed by removing clicks. That might be an effective way to defend against an ill-behaved plugin that didn’t namespace its removal of click events, for example:</p>
<pre><code>var elem = $( &quot;p&quot; );

elem.on( &quot;click&quot;, function( event ) {
    $( &quot;body&quot; ).append( &quot;I am a &quot; + event.type + &quot;!&quot; );
});

elem.on( &quot;pushy&quot;, function( event ) {
    $( &quot;body&quot; ).append( &quot;I am pushy but still a &quot; + event.type + &quot;!&quot; );
});

elem.trigger( &quot;click&quot; ); // Triggers both handlers

elem.off( &quot;click&quot; );

elem.trigger( &quot;click&quot; ); // Still triggers &quot;pushy&quot;

elem.off( &quot;pushy&quot; );</code></pre>
<p>These two properties are often used in conjunction with a <code>handle</code> hook function; the hook might, for example, change the event name from “click” to “pushy” before calling event handlers. See below for an example.</p>
<h4 id="the-handleobj-object">The handleObj object</h4>
<p>Many of the special event hook functions below are passed a <code>handleObj</code> object that provides more information about the event, how it was attached, and its current state. This object and its contents should be treated as read-only data, and only the properties below are documented for use by special event handlers. For the discussion below, assume an event is attached with this code:</p>
<pre><code>$( &quot;.dialog&quot; ).on( &quot;click.myPlugin&quot;, &quot;button&quot;, {
    mydata: 42
}, myHandler );</code></pre>
<p><code>type</code>: String: The type of event, such as <code>"click"</code>. When special event mapping is used via <code>bindType</code> or <code>delegateType</code>, this will be the mapped type.</p>
<p><code>origType</code>: String: The original type name (in this case, <code>"click"</code>) regardless of whether it was mapped via <code>bindType</code> or <code>delegateType</code>. So when a “pushy” event is mapped to “click” its <code>origType</code> would be “pushy”. See the examples in those special event properties above for more detail.</p>
<p><code>namespace</code>: String: Namespace(s), if any, provided when the event was attached, such as <code>"myPlugin"</code>. When multiple namespaces are given, they are separated by periods and sorted in ascending alphabetical order. If no namespaces are provided, this property is an empty string.</p>
<p><code>selector</code>: String: For delegated events, this is the selector used to filter descendant elements and determine if the handler should be called. In the example it is <code>"button"</code>. For directly bound events, this property is <code>null</code>.</p>
<p><code>data</code>: Object: The data, if any, passed to jQuery during event binding, e.g. <code>{ myData: 42 }</code>. If the data argument was omitted or <code>undefined</code>, this property is <code>undefined</code> as well.</p>
<p><code>handler</code>: function( event: jQuery.Event ): Event handler function passed to jQuery during event binding; in the example it is a reference to <code>myHandler</code>. If <code>false</code> was passed during event binding, the handler refers to a single shared function that simply returns <code>false</code>.</p>
<h4 id="setup-function-data-object-namespaces-eventhandle-function">setup: function( data: Object, namespaces, eventHandle: function )</h4>
<p>The setup hook is called the first time an event of a particular type is attached to an element; this provides the hook an opportunity to do processing that will apply to all events of this type on this element. The <code>this</code> keyword will be a reference to the element where the event is being attached and <code>eventHandle</code> is jQuery’s event handler function. In most cases the <code>namespaces</code> argument should not be used, since it only represents the namespaces of the <em>first</em> event being attached; subsequent events may not have this same namespaces.</p>
<p>This hook can perform whatever processing it desires, including attaching its own event handlers to the element or to other elements and recording setup information on the element using the <code>jQuery.data()</code> method. If the setup hook wants jQuery to add a browser event (via <code>addEventListener</code> or <code>attachEvent</code>, depending on browser) it should return <code>false</code>. In all other cases, jQuery will not add the browser event, but will continue all its other bookkeeping for the event. This would be appropriate, for example, if the event was never fired by the browser but invoked by <code>.trigger()</code>. To attach the jQuery event handler in the setup hook, use the <code>eventHandle</code> argument.</p>
<h4 id="teardown-function">teardown: function()</h4>
<p>The teardown hook is called when the final event of a particular type is removed from an element. The <code>this</code> keyword will be a reference to the element where the event is being cleaned up. This hook should return <code>false</code> if it wants jQuery to remove the event from the browser’s event system (via <code>removeEventListener</code> or <code>detachEvent</code>). In most cases, the setup and teardown hooks should return the same value.</p>
<p>If the setup hook attached event handlers or added data to an element through a mechanism such as <code>jQuery.data()</code>, the teardown hook should reverse the process and remove them. jQuery will generally remove the data and events when an element is totally removed from the document, but failing to remove data or events on teardown will cause a memory leak if the element stays in the document.</p>
<h4 id="add-function-handleobj">add: function( handleObj )</h4>
<p>Each time an event handler is added to an element through an API such as <code>.on()</code>, jQuery calls this hook. The <code>this</code> keyword will be the element to which the event handler is being added, and the <code>handleObj</code> argument is as described in the section above. The return value of this hook is ignored.</p>
<h4 id="remove-function-handleobj">remove: function( handleObj )</h4>
<p>When an event handler is removed from an element using an API such as <code>.off()</code>, this hook is called. The <code>this</code> keyword will be the element where the handler is being removed, and the <code>handleObj</code> argument is as described in the section above. The return value of this hook is ignored.</p>
<h4 id="trigger-function-event-jquery.event-data-object">trigger: function( event: jQuery.Event, data: Object )</h4>
<p>Called when the <code>.trigger()</code> or <code>.triggerHandler()</code> methods are used to trigger an event for the special type from code, as opposed to events that originate from within the browser. The <code>this</code> keyword will be the element being triggered, and the event argument will be a <code>jQuery.Event</code> object constructed from the caller’s input. At minimum, the event type, data, namespace, and target properties are set on the event. The data argument represents additional data passed by <code>.trigger()</code> if present.</p>
<p>The trigger hook is called early in the process of triggering an event, just after the <code>jQuery.Event</code> object is constructed and before any handlers have been called. It can process the triggered event in any way, for example by calling <code>event.stopPropagation()</code> or <code>event.preventDefault()</code> before returning. If the hook returns <code>false</code>, jQuery does not perform any further event triggering actions and returns immediately. Otherwise, it performs the normal trigger processing, calling any event handlers for the element and bubbling the event (unless propagation is stopped in advance or <code>noBubble</code> was specified for the special event) to call event handlers attached to parent elements.</p>
<h4 id="default-function-event-jquery.event-data-object">_default: function( event: jQuery.Event, data: Object )</h4>
<p>When the <code>.trigger()</code> method finishes running all the event handlers for an event, it also looks for and runs any method on the target object by the same name unless of the handlers called <code>event.preventDefault()</code>. So, <code>.trigger( "submit" )</code> will execute the <code>submit()</code> method on the element if one exists. When a <code>_default</code> hook is specified, the hook is called just prior to checking for and executing the element’s default method. If this hook returns the value <code>false</code> the element’s default method will be called; otherwise it is not.</p>
<h4 id="handle-function-event-jquery.event-data-object">handle: function( event: jQuery.Event, data: Object )</h4>
<p>jQuery calls a handle hook when the event has occurred and jQuery would normally call the user’s event handler specified by <code>.on()</code> or another event binding method. If the hook exists, jQuery calls it <em>instead of</em> that event handler, passing it the event and any data passed from <code>.trigger()</code> if it was not a native event. The <code>this</code> keyword is the DOM element being handled, and <code>event.handleObj</code> property has the detailed event information.</p>
<p>Based in the information it has, the handle hook should decide whether to call the original handler function which is in <code>event.handleObj.handler</code>. It can modify information in the event object before calling the original handler, but <em>must restore</em> that data before returning or subsequent unrelated event handlers may act unpredictably. In most cases, the handle hook should return the result of the original handler, but that is at the discretion of the hook. The handle hook is unique in that it is the only special event function hook that is called under its original special event name when the type is mapped using <code>bindType</code> and <code>delegateType</code>. For that reason, it is almost always an error to have anything other than a handle hook present if the special event defines a <code>bindType</code> and <code>delegateType</code>, since those other hooks will never be called.</p>
<h4 id="example-multiclick-event">Example: Multiclick event</h4>
<p>This <code>multiclick</code> special event maps itself into a standard click event, but uses a handle hook so that it can monitor the event and only deliver it when the user clicks on the element a multiple of the number of times specified during event binding.</p>
<p>The hook stores the current click count in the data object, so multiclick handlers on different elements don’t interfere with each other. It changes the event type to the original “multiclick” type before calling the handler and restores it to the mapped “click” type before returning:</p>
<pre><code>jQuery.event.special.multiclick = {
    delegateType: &quot;click&quot;,
    bindType: &quot;click&quot;,
    handle: function( event ) {
        var handleObj = event.handleObj;
        var targetData = jQuery.data( event.target );
        var ret = null;

        // If a multiple of the click count, run the handler
        targetData.clicks = ( targetData.clicks || 0 ) + 1;

        if ( targetData.clicks % event.data.clicks === 0 ) {
            event.type = handleObj.origType;
            ret = handleObj.handler.apply( this, arguments );
            event.type = handleObj.type;
            return ret;
        }
    }
};

// Sample usage
$( &quot;p&quot; ).on( &quot;multiclick&quot;, {
    clicks: 3
}, function( event ) {
    alert( &quot;clicked 3 times&quot; );
});</code></pre>
</body></html>
